<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <title>GLTF Viewer - AI ê¸°ë°˜ ëˆ„ì¶œ íƒì§€ ì‹œìŠ¤í…œ</title>
  <style>
    body {
      margin: 0;
      font-family: 'Inter', 'Arial', sans-serif;
      overflow: hidden;
      background-color: #121212;
      color: #E0E0E0;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    .right-panel {
      flex-grow: 1;
      background: #1A1D2E;
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #overlay-buttons {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10000;
      display: flex;
      gap: 10px;
    }

    #overlay-buttons button {
      padding: 10px 20px;
      font-size: 0.9rem;
      font-weight: 500;
      color: #00CFE8;
      background: transparent;
      border: 1px solid #00CFE8;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    #overlay-buttons button:hover {
      background: rgba(0, 207, 232, 0.1);
      box-shadow: 0 0 15px rgba(0, 207, 232, 0.3);
    }

    #overlay-buttons button.active {
      background: #00CFE8;
      color: #1A1D2E;
      box-shadow: 0 0 15px rgba(0, 207, 232, 0.5);
    }

    #popup {
      position: fixed;
      display: none;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(26, 29, 46, 0.88);
      backdrop-filter: blur(12px) saturate(190%);
      -webkit-backdrop-filter: blur(12px) saturate(190%);
      border: 1px solid rgba(0, 207, 232, 0.25);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 207, 232, 0.2);
      font-size: 14px;
      z-index: 9999;
      width: 50vw;
      min-width: 250px;
      overflow: auto;
      max-height: 80vh;
    }

    #popup-header {
      cursor: move;
      background: rgba(26, 29, 46, 0.7);
      padding: 10px 15px;
      border-bottom: 1px solid rgba(0, 207, 232, 0.3);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 16px 16px 0 0;
    }

    #popup-header button {
      background: transparent;
      color: #00CFE8;
      border: 1px solid #00CFE8;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      font-size: 14px;
      line-height: 26px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }

    #popup-header button:hover {
      background: rgba(0, 207, 232, 0.2);
      color: #FFFFFF;
      box-shadow: 0 0 10px rgba(0, 207, 232, 0.5);
    }

    #popup-content {
      width: 90%;
      padding: 15px;
      margin: 0 auto;
    }

    #info-panel {
      position: absolute;
      top: 80px;
      left: 20px;
      max-width: 300px;
      background: rgba(26, 29, 46, 0.88);
      backdrop-filter: blur(12px) saturate(190%);
      -webkit-backdrop-filter: blur(12px) saturate(190%);
      border: 1px solid rgba(0, 207, 232, 0.25);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 207, 232, 0.2);
      padding: 20px;
      color: #E0E0E0;
      font-size: 0.85rem;
      z-index: 100;
    }

    #info-panel h2 {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 15px;
      color: #00CFE8;
      border-bottom: 1px solid rgba(0, 207, 232, 0.3);
      padding-bottom: 10px;
    }

    #info-panel p {
      margin-bottom: 8px;
      line-height: 1.5;
    }

    #info-panel ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #info-panel li {
      margin-bottom: 5px;
    }

    #info-panel span {
      font-weight: 500;
      color: #FFFFFF;
    }

    .sensor-label {
      color: #E0E0E0;
      background-color: rgba(26, 29, 46, 0.7);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      position: absolute;
      transform: translateX(-50%) translateY(-160%);
      white-space: nowrap;
      pointer-events: none;
      border: 1px solid rgba(0, 207, 232, 0.3);
      z-index: 1;
    }

    #sensorChart {
      width: 100%;
      height: 100%;
      min-height: 300px;
    }

    .chart-container {
      width: 100%;
      height: auto;
      margin-top: 10px;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="right-panel" id="viewer"></div>
  </div>

  <div id="overlay-buttons">
    <button onclick="LearningStart()">AI í•™ìŠµ</button>
    <button onclick="DemoStart()">ë°ëª¨ ì‹œì‘</button>
    <button onclick="LeakDetection()">AI ê¸°ë°˜ ëˆ„ì¶œ ì¶”ì •</button>
    <button onclick="Dispersion()">ì•”ëª¨ë‹ˆì•„ í™•ì‚° ì–‘ìƒ</button>
  </div>

  <div id="info-panel">
    <h2>ì‹œë®¬ë ˆì´ì…˜ ì •ë³´</h2>
    <p>í˜„ì¬ ë°ëª¨: <span id="currentDemo">ëŒ€ê¸° ì¤‘</span></p>
    <p id="sensorInfo">ì„¼ì„œë¥¼ í´ë¦­í•˜ë©´ ì •ë³´ê°€ í‘œì‹œë©ë‹ˆë‹¤.</p>
    <div id="sensorList"></div>
  </div>

  <div id="popup">
    <div id="popup-header">
      <span><strong id="popup-title">ì •ë³´</strong></span>
      <button onclick="popup.style.display='none'; popupLocked=false;">âœ–</button>
    </div>
    <div id="popup-content"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    let scene, camera, renderer, loader, controls, currentModel;
    const popup = document.getElementById('popup');
    const popupHeader = document.getElementById('popup-header');
    const popupTitle = document.getElementById('popup-title');
    const currentDemoDisplay = document.getElementById('currentDemo');
    let popupLocked = false;  // íŒì—… ì ê¸ˆ ì—¬ë¶€

    init();
    loadModel('https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/model_GE-v1.glb');

    function init() {
      const container = document.getElementById('viewer');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1A1D2E);  // ì–´ë‘ìš´ íŒŒë€ìƒ‰ ë°°ê²½ìœ¼ë¡œ ë³€ê²½
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      const aspect = container.clientWidth / container.clientHeight;
      const dist = 15;
      camera = new THREE.OrthographicCamera(-dist * aspect, dist * aspect, dist, -dist, 0.1, 1000);
      camera.position.set(0, 0, -dist);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      loader = new THREE.GLTFLoader();

      // í–¥ìƒëœ ì¡°ëª… ì„¤ì •
      scene.add(new THREE.AmbientLight(0xaaaaaa, 0.7));
      const dirLight = new THREE.DirectionalLight(0x00CFE8, 0.5); // ì‚¬ì´ì–¸ ì»¬ëŸ¬ ê°•ì¡°
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);
      
      const pointLight = new THREE.PointLight(0xffffff, 0.3);
      pointLight.position.set(-5, -5, -5);
      scene.add(pointLight);

      animate();
      resetUI();
    }

    function resetUI() {
      // UI ìƒíƒœ ì´ˆê¸°í™”
      currentDemoDisplay.textContent = "ëŒ€ê¸° ì¤‘";
      document.getElementById('sensorInfo').textContent = "ì„¼ì„œë¥¼ í´ë¦­í•˜ë©´ ì •ë³´ê°€ í‘œì‹œë©ë‹ˆë‹¤.";
      document.getElementById('sensorList').innerHTML = "";
      
      // ê¸°ì¡´ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì´ˆê¸°í™”
      const buttons = document.querySelectorAll('#overlay-buttons button');
      buttons.forEach(btn => btn.classList.remove('active'));
    }

    function loadModel(path) {
      if (currentModel) scene.remove(currentModel);
      
      loader.load(path, function (gltf) {
        currentModel = gltf.scene;
        
        // ëª¨ë¸ ê°€ì‹œì„± í–¥ìƒì„ ìœ„í•œ ì„¤ì •
        currentModel.traverse(function(child) {
          if (child.isMesh) {
            // ê¸°ì¡´ ì¬ì§ˆì„ í–¥ìƒëœ ì¬ì§ˆë¡œ êµì²´
            const origMaterial = child.material;
            const enhancedMaterial = new THREE.MeshStandardMaterial({
              color: origMaterial.color || 0xCCCCCC,
              metalness: 0.3,
              roughness: 0.6,
              emissive: 0x222222,
              emissiveIntensity: 0.2
            });
            child.material = enhancedMaterial;
          }
        });
        
        scene.add(currentModel);
      }, undefined, function (error) {
        console.error('ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨:', error);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
      
      // ë¼ë²¨ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
      updateLabels();
    }

    function updateLabels() {
      // ë¼ë²¨ ìˆëŠ” ëª¨ë“  ìš”ì†Œ ì—…ë°ì´íŠ¸ (ìƒíƒœ íë¸Œ, ì„¼ì„œ ë“±)
      document.querySelectorAll('.sensor-label').forEach(label => {
        const id = label.getAttribute('data-id');
        if (!id) return;
        
        const object = scene.getObjectByName(id);
        if (object) {
          const vector = object.position.clone().project(camera);
          const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
          const y = (-vector.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
          label.style.left = `${x}px`;
          label.style.top = `${y}px`;
          label.style.display = vector.z < 1 ? 'block' : 'none';
        }
      });
    }

    // ì¥ë¹„ ìƒíƒœ ì •ìœ¡ë©´ì²´ ìƒì„± í•¨ìˆ˜
    function addStatusCubeAt(x, y, z, name) {
      // ê¸°ì¡´ ê°ì²´ ìˆìœ¼ë©´ ì œê±°
      const existingCube = scene.getObjectByName(name);
      if (existingCube) {
        scene.remove(existingCube);
      }
      
      const geometry = new THREE.BoxGeometry(2, 10, 3);
      const material = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.5,
        emissive: 0x003300,
        emissiveIntensity: 0.2
      });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(x, y, z);
      cube.name = name;
      scene.add(cube);
      
      // ë¼ë²¨ ì¶”ê°€
      const labelDiv = document.createElement('div');
      labelDiv.className = 'sensor-label';
      labelDiv.textContent = name;
      labelDiv.setAttribute('data-id', name);
      document.body.appendChild(labelDiv);
      
      return cube;
    }

    const clickableCubes = [];
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let INTERSECTED = null;

    // ë¼ë²¨ íë¸Œ ìƒì„±
    function addLabeledCube(x, y, z, name, size = 1, imagePath = null) {
      // ê¸°ì¡´ì— ìˆìœ¼ë©´ ì œê±°
      const existingCube = scene.getObjectByName(name);
      if (existingCube) {
        scene.remove(existingCube);
        clickableCubes.splice(clickableCubes.indexOf(existingCube), 1);
      }
      
      const geometry = new THREE.BoxGeometry(size, size, size);
      const material = new THREE.MeshStandardMaterial({
        color: 0x00CFE8,
        transparent: true,
        opacity: 0.7,
        emissive: 0x006774,
        emissiveIntensity: 0.3
      });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(x, y, z);
      cube.userData.name = name;
      cube.userData.image = imagePath;
      cube.name = name;
      scene.add(cube);
      clickableCubes.push(cube);

      // ë¼ë²¨
      const labelDiv = document.createElement('div');
      labelDiv.className = 'sensor-label';
      labelDiv.textContent = name;
      labelDiv.setAttribute('data-id', name);
      document.body.appendChild(labelDiv);
      
      // ì„¼ì„œ ì •ë³´ íŒ¨ë„ì— ì¶”ê°€
      const sensorList = document.getElementById('sensorList');
      const sensorItem = document.createElement('div');
      sensorItem.innerHTML = `<p>${name}: <span id="${name.replace(/\s+/g, '')}_value">N/A</span></p>`;
      sensorList.appendChild(sensorItem);
      
      return cube;
    }

    function LearningStart() {
      resetUI();
      document.querySelector('button[onclick="LearningStart()"]').classList.add('active');
      currentDemoDisplay.textContent = "AI í•™ìŠµ";
      
      popupLocked = true;  // AI í•™ìŠµì—ì„œ ìƒì„±ëœ íŒì—…ì€ ê³ ì •
      popupTitle.textContent = "AI í•™ìŠµ";
      
      const imgPath = "https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png";

      const html = `
      <div style="text-align: center; margin-bottom: 15px;">
        <img src="${imgPath}" alt="AI í•™ìŠµ ì´ë¯¸ì§€" style="width:90%; max-height:300px; object-fit:contain; margin-top:5px; border-radius:8px; border:1px solid rgba(0,207,232,0.3);">
      </div>
      <p style="line-height:1.6;">AI í•™ìŠµì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ëˆ„ì¶œ íŒ¨í„´ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤.</p>
      <div style="margin-top:15px; background: rgba(0,207,232,0.1); padding:10px; border-radius:8px; border:1px solid rgba(0,207,232,0.2);">
        <h3 style="margin-top:0; color:#00CFE8; font-size:1rem;">í•™ìŠµ ì§„í–‰ ìƒí™©</h3>
        <p>ë°ì´í„° í¬ì¸íŠ¸: <strong>23,450ê°œ</strong></p>
        <p>ëª¨ë¸ ì •í™•ë„: <strong>97.2%</strong></p>
        <p>ë‚¨ì€ ì‹œê°„: <strong>ì•½ 2ë¶„</strong></p>
      </div>
    `;

      document.getElementById('popup-content').innerHTML = html;
      popup.style.display = 'block';
    }

    let leakChart;             // Chart.js ì¸ìŠ¤í„´ìŠ¤
    let leakTimer;             // setInterval íƒ€ì´ë¨¸
    let leakData = [];         // ì „ì²´ ë°ì´í„° ë°°ì—´
    let leakIndex = 0;         // í˜„ì¬ ì‹œì  ì¸ë±ìŠ¤

    function DemoStart() {
      resetUI();
      document.querySelector('button[onclick="DemoStart()"]').classList.add('active');
      currentDemoDisplay.textContent = "ë°ëª¨ ì‹œì‘";
      
      clearInterval(leakTimer);  // ì´ì „ ì‹¤í–‰ ì¤‘ì§€
      leakChart?.destroy();      // ê¸°ì¡´ ê·¸ë˜í”„ ì œê±°
      leakData = [];
      leakIndex = 0;
      popupLocked = true;

      const speedFactor = 5; // âœ… në°° ë¹ ë¥´ê²Œ (ì˜ˆ: 5ë°° ë¹ ë¥´ê²Œ)

      fetch('https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/leak_7.csv') 
        .then(response => response.text())
        .then(csvText => {
          const lines = csvText.trim().split('\n');
          const headers = lines[0].split(',');
          const timeIdx = headers.indexOf('Time (sec)');

          // value ì»¬ëŸ¼ ì¸ë±ìŠ¤ë“¤ (value1, value2, ...)
          const valueIndices = headers
            .map((h, i) => ({ name: h.trim(), idx: i }))
            .filter(obj => obj.name !== 'Time (sec)');

          for (let i = 1; i < lines.length; i++) {
            const parts = lines[i].split(',');
            const time = parseFloat(parts[timeIdx]);
            const values = valueIndices.map(obj => parseFloat(parts[obj.idx]));
            leakData.push({ x: time, yValues: values });
          }

          popupTitle.textContent = "ì‹¤ì‹œê°„ ì„¼ì„œ ë°ì´í„°";
          document.getElementById('popup-content').innerHTML = `
            <div class="chart-container">
              <canvas id="leakChart"></canvas>
            </div>
            <div style="margin-top: 15px; font-size: 0.9rem; color: #E0E0E0;">
              <p>í˜„ì¬ ì‹œê°„: <span id="currentTime">0.00</span>ì´ˆ</p>
              <p>ìµœëŒ€ ë†ë„: <span id="maxConcentration">0.00</span> ppm</p>
            </div>
          `;
          popup.style.display = 'block';

          const ctx = document.getElementById('leakChart').getContext('2d');
          leakChart = new Chart(ctx, {
            type: 'line',
            data: {
              datasets: valueIndices.map((obj, index) => ({
                label: obj.name,
                data: [],
                borderColor: `hsl(${(index * 60) % 360}, 70%, 50%)`,
                backgroundColor: `hsla(${(index * 60) % 360}, 70%, 50%, 0.2)`,
                fill: false,
                tension: 0.2,
                pointRadius: 1,
                pointHoverRadius: 3
              }))
            },
            options: {
              animation: false,
              scales: {
                x: {
                  type: 'linear',
                  title: { display: true, text: 'Time [s]', color: '#E0E0E0' },
                  min: 0,
                  grid: { color: 'rgba(0, 207, 232, 0.1)' },
                  ticks: { color: '#B0B0B0' }
                },
                y: {
                  title: { display: true, text: 'NH3 [ppm]', color: '#E0E0E0' },
                  min: 0,
                  grid: { color: 'rgba(0, 207, 232, 0.1)' },
                  ticks: { color: '#B0B0B0' }
                }
              },
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  labels: { color: '#E0E0E0' }
                },
                tooltip: {
                  backgroundColor: 'rgba(26, 29, 46, 0.9)',
                  borderColor: 'rgba(0, 207, 232, 0.3)',
                  borderWidth: 1,
                  titleColor: '#00CFE8',
                  bodyColor: '#E0E0E0',
                  displayColors: true,
                  padding: 10
                }
              }
            }
          });

          // 1ì´ˆ ê°„ê²©ìœ¼ë¡œ ê°’ ì¶”ê°€
          leakTimer = setInterval(() => {
            if (leakIndex < leakData.length) {
              const point = leakData[leakIndex];
              
              document.getElementById('currentTime').textContent = point.x.toFixed(2);
              let maxVal = 0;
              
              point.yValues.forEach((val, idx) => {
                leakChart.data.datasets[idx].data.push({ x: point.x, y: val });
                if (val > maxVal) maxVal = val;
              });
              
              document.getElementById('maxConcentration').textContent = maxVal.toFixed(2);
              
              // ğŸ‘‰ xì¶• max ê°’ì„ í˜„ì¬ ì‹œê°„ + 1ë¡œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
              leakChart.options.scales.x.max = leakData[leakIndex].x + 1;
              leakChart.update();
              leakIndex++;
            } else {
              clearInterval(leakTimer); // ì¢…ë£Œ
            }
          }, 1000 / speedFactor);
        })
        .catch(error => {
          popupTitle.textContent = "ì˜¤ë¥˜";
          document.getElementById('popup-content').innerHTML = `<p style="color:#ff4d4d;">CSV ë¡œë“œ ì‹¤íŒ¨: ${error}</p>`;
          popup.style.display = 'block';
        });
    }

    function LeakDetection() {
      resetUI();
      document.querySelector('button[onclick="LeakDetection()"]').classList.add('active');
      currentDemoDisplay.textContent = "AI ê¸°ë°˜ ëˆ„ì¶œ ì¶”ì •";
      
      clearInterval(leakTimer);
      leakChart?.destroy();
      leakData = [];
      leakIndex = 0;
      popupLocked = true;

      const speedFactor = 5;  // në°° ë¹ ë¥´ê²Œ

      // ìƒíƒœ íë¸Œ ìƒì„±
      const statusCube1 = addStatusCubeAt(3.5, -1, 2, 'GE#1');
      const statusCube2 = addStatusCubeAt(-0.4, -1, 2, 'GE#2');
      const statusCube3 = addStatusCubeAt(-4.3, -1, 2, 'GE#3');

      popupTitle.textContent = "AI ëˆ„ì¶œ ì¶”ì •";
      document.getElementById('popup-content').innerHTML = `
        <div style="margin-bottom: 15px; background: rgba(0,207,232,0.1); padding:10px; border-radius:8px; border:1px solid rgba(0,207,232,0.2);">
          <h3 style="margin-top:0; color:#00CFE8; font-size:1rem;">ëˆ„ì¶œ ì¶”ì • ê²°ê³¼</h3>
          <p>ì¶”ì • ëˆ„ì¶œ ìœ„ì¹˜: <strong>GE#1</strong></p>
          <p>ì¶”ì • í™•ë¥ : <strong id="leakProbability">0%</strong></p>
          <p>í˜„ì¬ ë¶„ì„ ì‹œê°„: <strong id="analysisTime">0.00ì´ˆ</strong></p>
        </div>
        <div class="chart-container">
          <canvas id="leakChart"></canvas>
        </div>
      `;
      popup.style.display = 'block';

      fetch('https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/leakDetection.csv') 
        .then(response => response.text())
        .then(csvText => {
          const lines = csvText.trim().split('\n');
          const headers = lines[0].split(',');
          const timeIdx = headers.indexOf('Time (sec)');

          // value ì»¬ëŸ¼ ì¸ë±ìŠ¤ë“¤ (value1, value2, ...)
          const valueIndices = headers
            .map((h, i) => ({ name: h.trim(), idx: i }))
            .filter(obj => obj.name !== 'Time (sec)');

          for (let i = 1; i < lines.length; i++) {
            const parts = lines[i].split(',');
            const time = parseFloat(parts[timeIdx]);
            const values = valueIndices.map(obj => parseFloat(parts[obj.idx]));
            leakData.push({ x: time, yValues: values });
          }

          const ctx = document.getElementById('leakChart').getContext('2d');
          leakChart = new Chart(ctx, {
            type: 'line',
            data: {
              datasets: valueIndices.map((obj, index) => ({
                label: obj.name,
                data: [],
                borderColor: `hsl(${(index * 60) % 360}, 70%, 50%)`,
                backgroundColor: `hsla(${(index * 60) % 360}, 70%, 50%, 0.2)`,
                fill: false,
                tension: 0.2,
                pointRadius: 1,
                pointHoverRadius: 3
              }))
            },
            options: {
              animation: false,
              scales: {
                x: {
                  type: 'linear',
                  title: { display: true, text: 'Time [s]', color: '#E0E0E0' },
                  min: 0,
                  grid: { color: 'rgba(0, 207, 232, 0.1)' },
                  ticks: { color: '#B0B0B0' }
                },
                y: {
                  title: { display: true, text: 'NH3 [ppm]', color: '#E0E0E0' },
                  min: 0,
                  grid: { color: 'rgba(0, 207, 232, 0.1)' },
                  ticks: { color: '#B0B0B0' }
                }
              },
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  labels: { color: '#E0E0E0' }
                },
                tooltip: {
                  backgroundColor: 'rgba(26, 29, 46, 0.9)',
                  borderColor: 'rgba(0, 207, 232, 0.3)',
                  borderWidth: 1,
                  titleColor: '#00CFE8',
                  bodyColor: '#E0E0E0',
                  displayColors: true,
                  padding: 10
                }
              }
            }
          });

          // 1ì´ˆ ê°„ê²©ìœ¼ë¡œ ê°’ ì¶”ê°€
          leakTimer = setInterval(() => {
            if (leakIndex < leakData.length) {
              const point = leakData[leakIndex];
              const probability = Math.min(100, Math.floor(point.x * 2.5));
              
              document.getElementById('leakProbability').textContent = `${probability}%`;
              document.getElementById('analysisTime').textContent = `${point.x.toFixed(2)}ì´ˆ`;
              
              point.yValues.forEach((val, idx) => {
                leakChart.data.datasets[idx].data.push({ x: point.x, y: val });
              });
              // ğŸ‘‰ xì¶• max ê°’ì„ í˜„ì¬ ì‹œê°„ + 1ë¡œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
              leakChart.options.scales.x.max = leakData[leakIndex].x + 1;

              // ë™ì ìœ¼ë¡œ íë¸Œ ìƒ‰ìƒ ì—…ë°ì´íŠ¸
              const red1 = Math.floor(point.yValues[0] * 255);
              const green1 = Math.floor((1 - point.yValues[0]) * 255);
              statusCube1.material.color.setRGB(red1 / 255, green1 / 255, 0);
              statusCube1.material.emissive.setRGB(red1 / 255 * 0.3, green1 / 255 * 0.3, 0);

              const red2 = Math.floor(point.yValues[1] * 255);
              const green2 = Math.floor((1 - point.yValues[1]) * 255);
              statusCube2.material.color.setRGB(red2 / 255, green2 / 255, 0);
              statusCube2.material.emissive.setRGB(red2 / 255 * 0.3, green2 / 255 * 0.3, 0);

              const red3 = Math.floor(point.yValues[2] * 255);
              const green3 = Math.floor((1 - point.yValues[2]) * 255);
              statusCube3.material.color.setRGB(red3 / 255, green3 / 255, 0);
              statusCube3.material.emissive.setRGB(red3 / 255 * 0.3, green3 / 255 * 0.3, 0);

              leakChart.update();
              leakIndex++;
            } else {
              clearInterval(leakTimer); // ì¢…ë£Œ
            }
          }, 1000 / speedFactor);
        })
        .catch(error => {
          popupTitle.textContent = "ì˜¤ë¥˜";
          document.getElementById('popup-content').innerHTML = `<p style="color:#ff4d4d;">CSV ë¡œë“œ ì‹¤íŒ¨: ${error}</p>`;
          popup.style.display = 'block';
        });
    }

    function Dispersion() {
      resetUI();
      document.querySelector('button[onclick="Dispersion()"]').classList.add('active');
      currentDemoDisplay.textContent = "ì•”ëª¨ë‹ˆì•„ í™•ì‚° ì–‘ìƒ";
      popupLocked = false;
      popup.style.display = 'none';
      
      // ê¸°ì¡´ í™•ì‚° ê´€ë ¨ ê°ì²´ ì œê±°
      scene.children.forEach(obj => {
        if (obj.userData && obj.userData.type === 'dispersion') {
          scene.remove(obj);
        }
      });
      
      // íŒŒí‹°í´ ë°°ì—´ ì´ˆê¸°í™”
      const particles = [];
      
      // [1] ì™¸ë¶€ ë°•ìŠ¤ í¬ê¸° ì •ì˜
      const boxWidth = 13.8;
      const boxHeight = 21.5;
      const boxDepth = 7.5;
      const halfW = boxWidth / 2;
      const halfH = boxHeight / 2;
      const halfD = boxDepth / 2;

      // [2] ì™¸ë¶€ ë°•ìŠ¤ ê·¸ë¦¬ê¸°
      const outerBox = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
      const outerEdges = new THREE.EdgesGeometry(outerBox);
      const outerMaterial = new THREE.LineBasicMaterial({ color: 0x00CFE8, opacity: 0.7, transparent: true });
      const outerWireframe = new THREE.LineSegments(outerEdges, outerMaterial);
      outerWireframe.userData.type = 'dispersion';
      scene.add(outerWireframe);

      // [3] ë‚´ë¶€ ì¥ì• ë¬¼ ì •ì˜ (center + size)
      const obstacles = [
        { center: new THREE.Vector3(3.5, -1, 2), size: new THREE.Vector3(2, 10, 3) },
        { center: new THREE.Vector3(-0.4, -1, 2), size: new THREE.Vector3(2, 10, 3) },
        { center: new THREE.Vector3(-4.3, -1, 2), size: new THREE.Vector3(2, 10, 3) }
      ];

      // min/max ê³„ì‚° ë° ì‹œê°í™”
      obstacles.forEach(obs => {
        const halfSize = obs.size.clone().multiplyScalar(0.5);
        obs.min = obs.center.clone().sub(halfSize);
        obs.max = obs.center.clone().add(halfSize);

        const geom = new THREE.BoxGeometry(obs.size.x, obs.size.y, obs.size.z);
        const edges = new THREE.EdgesGeometry(geom);
        const mat = new THREE.LineBasicMaterial({ color: 0xff0000, opacity: 0.7, transparent: true });
        const wire = new THREE.LineSegments(edges, mat);
        wire.position.copy(obs.center); // ì¤‘ì‹¬ ì¢Œí‘œ ê¸°ì¤€ ìœ„ì¹˜
        wire.userData.type = 'dispersion';
        scene.add(wire);
      });

      // 9ê°œ ê·¸ë¦¬ë“œ ì •ì˜ (3x3 â†’ x,z ë°©í–¥ ë¶„í• )
      // âœ… XY í‰ë©´ìƒ ê·¸ë¦¬ë“œ ì„¤ì •
      const gridCountX = 3;
      const gridCountY = 3;
      const gridWidth = boxWidth / gridCountX;
      const gridHeight = boxHeight / gridCountY;

      const gridPlanes = [];
      for (let i = 0; i < gridCountX; i++) {
        for (let j = 0; j < gridCountY; j++) {
          const material = new THREE.MeshBasicMaterial({
            color: 0x00CFE8,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide
          });
          const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(gridWidth, gridHeight),
            material
          );
          // XY í‰ë©´ â†’ íšŒì „ ì—†ìŒ
          plane.position.set(
            -halfW + gridWidth * (i + 0.5),
            -halfH + gridHeight * (j + 0.5),
            -halfD + 0.01  // XY í‰ë©´ì— z ê³ ì •
          );
          plane.userData.type = 'dispersion';
          scene.add(plane);
          gridPlanes.push({ mesh: plane, count: 0 });
        }
      }
      
      // [4] ëˆ„ì¶œì› ìœ„ì¹˜
      const leakSource = new THREE.Vector3(4.8, 2.0, 0.4);
      
      // ëˆ„ì¶œì› ì‹œê°í™”
      const sourceGeometry = new THREE.SphereGeometry(0.3, 16, 16);
      const sourceMaterial = new THREE.MeshStandardMaterial({
        color: 0xff4500,
        emissive: 0xcc3700,
        emissiveIntensity: 0.5,
        metalness: 0.3,
        roughness: 0.4
      });
      const sourceMesh = new THREE.Mesh(sourceGeometry, sourceMaterial);
      sourceMesh.position.copy(leakSource);
      sourceMesh.userData.type = 'dispersion';
      scene.add(sourceMesh);

      // [5] íŒŒí‹°í´ ì„¤ì •
      const maxParticles = 1000;
      const interval = 100;
      const speed = 0.02;
      const maxAge = 100.0;

      function createParticle() {
        const direction = new THREE.Vector3(
          Math.random() * 2 - 1,
          Math.random() * 2 - 1,
          Math.random() * 2 - 1
        ).normalize();

        const material = new THREE.MeshBasicMaterial({
          color: 0xff4500,
          transparent: true,
          opacity: 0.6
        });

        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 6, 6),
          material
        );
        particle.position.copy(leakSource);
        particle.userData = {
          direction,
          age: 0,
          type: 'dispersion'
        };
        scene.add(particle);
        particles.push(particle);
      }

      const particleInterval = setInterval(() => {
        if (particles.length < maxParticles) createParticle();
      }, interval);

      function animateDispersion() {
        if (!scene.getObjectByName(sourceMesh.uuid)) {
          // í™•ì‚° ì‹œë®¬ë ˆì´ì…˜ì´ ì¤‘ë‹¨ëœ ê²½ìš°
          cancelAnimationFrame(dispersionFrameId);
          clearInterval(particleInterval);
          return;
        }
        
        dispersionFrameId = requestAnimationFrame(animateDispersion);

        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          const delta = p.userData.direction.clone().multiplyScalar(speed);
          const nextPos = p.position.clone().add(delta);

          // [6-1] ì™¸ë¶€ ë°•ìŠ¤ ë°˜ì‚¬
          if (Math.abs(nextPos.x) > halfW) {
            p.userData.direction.reflect(new THREE.Vector3(1, 0, 0));
            p.position.x = Math.sign(p.position.x) * halfW;
          }
          if (Math.abs(nextPos.y) > halfH) {
            p.userData.direction.reflect(new THREE.Vector3(0, 1, 0));
            p.position.y = Math.sign(p.position.y) * halfH;
          }
          if (Math.abs(nextPos.z) > halfD) {
            p.userData.direction.reflect(new THREE.Vector3(0, 0, 1));
            p.position.z = Math.sign(p.position.z) * halfD;
          }

          // [6-2] ë‚´ë¶€ ì¥ì• ë¬¼ ë°˜ì‚¬
          for (const obs of obstacles) {
            if (
              nextPos.x > obs.min.x && nextPos.x < obs.max.x &&
              nextPos.y > obs.min.y && nextPos.y < obs.max.y &&
              nextPos.z > obs.min.z && nextPos.z < obs.max.z
            ) {
              const entry = p.position;

              const distToMin = entry.clone().sub(obs.min);
              const distToMax = obs.max.clone().sub(entry);
              const absMin = new THREE.Vector3(Math.abs(distToMin.x), Math.abs(distToMin.y), Math.abs(distToMin.z));
              const absMax = new THREE.Vector3(Math.abs(distToMax.x), Math.abs(distToMax.y), Math.abs(distToMax.z));

              const minDist = Math.min(
                absMin.x, absMin.y, absMin.z,
                absMax.x, absMax.y, absMax.z
              );

              let normal = new THREE.Vector3(0, 0, 0);
              if (minDist === absMin.x) normal.set(-1, 0, 0);
              else if (minDist === absMax.x) normal.set(1, 0, 0);
              else if (minDist === absMin.y) normal.set(0, -1, 0);
              else if (minDist === absMax.y) normal.set(0, 1, 0);
              else if (minDist === absMin.z) normal.set(0, 0, -1);
              else if (minDist === absMax.z) normal.set(0, 0, 1);

              p.userData.direction.reflect(normal);
            }
          }

          // ìœ„ì¹˜ ì´ë™
          p.position.add(p.userData.direction.clone().multiplyScalar(speed));

          // [7] ìƒ‰ìƒ ë° íˆ¬ëª…ë„ ë³€í™”
          p.userData.age += speed * 5;
          const t = Math.min(p.userData.age / maxAge, 1);
          const r = 1;
          const g = t < 0.5 ? t * 2 : 1;
          const b = 0;
          const alpha = t < 0.5 ? 0.6 : 0.6 * (1 - (t - 0.5) * 2);

          p.material.color.setRGB(r, g, b);
          p.material.opacity = alpha;

          // [8] ìˆ˜ëª… ì´ˆê³¼ ì‹œ ì œê±°
          if (p.userData.age > maxAge) {
            scene.remove(p);
            particles.splice(i, 1);
          }

          // ê·¸ë¦¬ë“œë³„ ì…ì ìˆ˜ ì´ˆê¸°í™”
          gridPlanes.forEach(g => g.count = 0);

          // XY í‰ë©´ ê¸°ì¤€ìœ¼ë¡œ ì…ì ë¶„í¬ ì¹´ìš´íŒ…
          particles.forEach(p => {
            const px = p.position.x + halfW;
            const py = p.position.y + halfH;

            const i = Math.floor(px / gridWidth);
            const j = Math.floor(py / gridHeight);

            if (i >= 0 && i < gridCountX && j >= 0 && j < gridCountY) {
              const index = i * gridCountY + j;
              gridPlanes[index].count++;
            }
          });

          // ìµœëŒ“ê°’ ê³„ì‚°
          const counts = gridPlanes.map(g => g.count);
          const maxCount = Math.max(...counts);
          const minCount = Math.min(...counts);

          // ìƒ‰ìƒ ì—…ë°ì´íŠ¸ (ì´ˆë¡ â†’ ë¹¨ê°•)
          gridPlanes.forEach(g => {
            const t = maxCount > 0 ? (g.count - minCount) / (maxCount - minCount || 1) : 0;
            const r = t;
            const gVal = 1 - t;
            const b = 0.3 * (1 - t); // ì•½ê°„ì˜ íŒŒë€ìƒ‰ ì¶”ê°€ë¡œ ì‹œì•ˆìƒ‰ íš¨ê³¼
            g.mesh.material.color.setRGB(r, gVal, b);
          });
        }
      }

      let dispersionFrameId = requestAnimationFrame(animateDispersion);
    }

    let isDragging = false, offsetX = 0, offsetY = 0;

    popupHeader.addEventListener('mousedown', (e) => {
      if (e.target.tagName.toLowerCase() === 'button') return; // ë²„íŠ¼ í´ë¦­ ì‹œ ë“œë˜ê·¸ ë°©ì§€
      isDragging = true;
      const rect = popup.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        popup.style.left = (e.clientX - offsetX) + 'px';
        popup.style.top = (e.clientY - offsetY) + 'px';
        popup.style.transform = 'none'; // ë“œë˜ê·¸ ì‹œ transform ì œê±°
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('resize', () => {
      const container = document.getElementById('viewer');
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    window.addEventListener('click', (event) => {
      // 1. UI ìš”ì†Œë©´ raycaster ê²€ì‚¬ ìƒëµ
      if (
        event.target.closest('#popup') ||
        event.target.closest('#overlay-buttons') ||
        event.target.closest('#info-panel')
      ) return;

      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(clickableCubes);

      if (intersects.length > 0) {
        // ì •ìƒ í´ë¦­ ì‹œ íŒì—… í‘œì‹œ
        const obj = intersects[0].object;
        const name = obj.userData.name;
        const imgPath = obj.userData.image || 'default.png';

        const html = `
          <div style="text-align: center; margin-bottom: 15px;">
            <img src="${imgPath}" alt="${name}" style="width:90%; max-height:200px; object-fit:contain; margin-top:5px; border-radius:8px; border:1px solid rgba(0,207,232,0.3);">
          </div>
          <div style="background: rgba(0,207,232,0.1); padding:10px; border-radius:8px; border:1px solid rgba(0,207,232,0.2);">
            <h3 style="margin-top:0; color:#00CFE8; font-size:1rem;">${name} ì •ë³´</h3>
            <p>ìœ„ì¹˜: (${obj.position.x.toFixed(2)}, ${obj.position.y.toFixed(2)}, ${obj.position.z.toFixed(2)})</p>
            <p>ìƒíƒœ: <strong>ì •ìƒ</strong></p>
            <p>ì¸¡ì •ê°’: <strong>0.42 ppm</strong></p>
          </div>
        `;
        popupTitle.textContent = name;
        document.getElementById('popup-content').innerHTML = html;
        popup.style.display = 'block';
        popup.style.top = '10%';
        popup.style.left = '50%';
        popup.style.transform = 'translateX(-50%)';
        popupLocked = false;

      } else {
        if (!popupLocked) popup.style.display = 'none';  // ì ê¸ˆëœ íŒì—…ì€ ë‹«íˆì§€ ì•ŠìŒ
      }
    });

    window.addEventListener('mousemove', (event) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(clickableCubes);

      if (intersects.length > 0) {
        if (INTERSECTED != intersects[0].object) {
          if (INTERSECTED) {
            INTERSECTED.material.color.set(0x00CFE8); // ì›ë˜ ìƒ‰ìœ¼ë¡œ
            INTERSECTED.material.emissive.set(0x006774);
          }
          INTERSECTED = intersects[0].object;
          INTERSECTED.material.color.set(0xffff00); // hover ì‹œ ë…¸ë€ìƒ‰
          INTERSECTED.material.emissive.set(0x555500);
          
          // ë§ˆìš°ìŠ¤ ì˜¤ë²„ ì‹œ ì„¼ì„œ ì •ë³´ í‘œì‹œ
          document.getElementById('sensorInfo').textContent = `${INTERSECTED.userData.name} ìœ„ì¹˜: (${INTERSECTED.position.x.toFixed(2)}, ${INTERSECTED.position.y.toFixed(2)}, ${INTERSECTED.position.z.toFixed(2)})`;
        }
      } else {
        if (INTERSECTED) {
          INTERSECTED.material.color.set(0x00CFE8);
          INTERSECTED.material.emissive.set(0x006774);
          INTERSECTED = null;
          document.getElementById('sensorInfo').textContent = "ì„¼ì„œë¥¼ í´ë¦­í•˜ë©´ ì •ë³´ê°€ í‘œì‹œë©ë‹ˆë‹¤.";
        }
      }
    });

    // ì„¼ì„œ ì¶”ê°€
    addLabeledCube(3.45, 1.11, -0.565, 'Sensor #1', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(-0.507, 1.11, -0.565, 'Sensor #2', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(-4.46, 1.11, -0.565, 'Sensor #3', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(4.26, 1.11, 0.360, 'Sensor #4', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(0.304, 1.11, 0.360, 'Sensor #5', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(-3.65, 1.11, 0.360, 'Sensor #6', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
  </script>
</body>
</html>
