<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI 누출원 탐지 시스템 (Light Mode - Wireframe)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      background-color: #f0f2f5; /* Light mode background */
      color: #333333; /* Darker text for light mode */
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    .right-panel {
      flex-grow: 1;
      background: #ffffff; /* Canvas container background */
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .ui-panel { /* General style for popups and modals */
      position: absolute;
      background: rgba(255, 255, 255, 0.9); /* Lighter background for panels */
      backdrop-filter: blur(10px) saturate(180%);
      -webkit-backdrop-filter: blur(10px) saturate(180%);
      border: 1px solid rgba(0, 100, 180, 0.2); /* Softer border color */
      border-radius: 12px; /* Slightly softer corners */
      box-shadow: 0 6px 24px rgba(0, 100, 180, 0.15); /* Softer shadow */
      padding: 20px;
      color: #2c3e50; /* Darker text for UI panels */
      z-index: 50;
    }

    #overlay-buttons {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 60;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #overlay-buttons button {
      padding: 10px 15px;
      font-size: 0.9rem;
      font-weight: 500;
      color: #007bff; /* Primary blue for buttons */
      background: rgba(255, 255, 255, 0.8); /* Light background for buttons */
      border: 1px solid #007bff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    #overlay-buttons button:hover {
      background: rgba(0, 123, 255, 0.1); /* Light blue hover */
      box-shadow: 0 0 12px rgba(0, 123, 255, 0.2);
    }

    #popup { /* 그래프 팝업창 크기 및 위치 조정 */
      position: fixed; /* 화면 기준 위치 고정 */
      display: none;
      bottom: 20px; /* 화면 하단에 위치 */
      right: 20px;  /* 화면 오른쪽에 위치 */
      background: rgba(248, 249, 250, 0.95);  
      backdrop-filter: blur(10px) saturate(180%);
      -webkit-backdrop-filter: blur(10px) saturate(180%);
      border: 1px solid rgba(108, 117, 125, 0.3);  
      border-radius: 12px; /* 모서리 둥글게 */
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);  
      font-size: 13px; /* 폰트 크기 약간 줄임 */
      z-index: 100;
      width: 450px; /* 너비 줄임 */
      max-width: 90vw; /* 최대 너비 설정 */
      height: 350px; /* 높이 줄임 */
      max-height: 50vh; /* 최대 높이 설정 */
    }

    #popup-header {
      cursor: move;
      padding: 10px 15px; /* 패딩 줄임 */
      border-bottom: 1px solid rgba(108, 117, 125, 0.2);  
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 12px 12px 0 0; /* 상단 모서리만 둥글게 */
      color: #007bff;  
      font-weight: 600;
      font-size: 0.95em; /* 헤더 폰트 크기 약간 줄임 */
    }

    #popup-content {
      width: auto; /* 자동 너비 */
      padding: 15px; /* 패딩 줄임 */
      margin: 0;  
      height: calc(100% - 45px); /* 헤더 높이 제외한 전체 높이 */
      overflow-y: auto;
      color: #343a40;  
    }
     #popup-content canvas { /* 캔버스 크기가 부모 요소에 맞게 조정되도록 */
        max-width: 100%;
        max-height: 100%;
    }


    #closeButton {
      background: transparent;
      color: #007bff;
      border: 1px solid #007bff;
      border-radius: 50%;
      width: 24px; /* 버튼 크기 줄임 */
      height: 24px;
      font-size: 14px; /* 아이콘 크기 줄임 */
      line-height: 22px; /* 아이콘 수직 정렬 */
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }

    #closeButton:hover {
      background: rgba(0, 123, 255, 0.1);
      color: #0056b3;  
    }

    #graphModal {  
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 700px;
      height: auto;
      max-height: 550px;
      z-index: 110;
      display: none;
      flex-direction: column;
    }

    #graphModal h3 {
      font-size: 1.4rem;
      font-weight: 600;
      color: #007bff;  
      margin-top: 0;
      margin-bottom: 20px;
      text-align: center;
    }

    #graphCanvasContainer {
      width: 100%;
      flex-grow: 1;
      min-height: 300px;
    }

    #closeGraphButton {  
      position: absolute;
      top: 15px;
      right: 15px;
      background: transparent;
      color: #007bff;
      border: 1px solid #007bff;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      font-size: 18px;
      line-height: 30px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }

    #closeGraphButton:hover {
      background: rgba(0, 123, 255, 0.1);
      color: #0056b3;
    }

    /* Sensor Labels */
    .sensor-label {
      color: #495057;  
      background-color: rgba(255, 255, 255, 0.75);  
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      position: absolute;
      transform: translateX(-50%) translateY(-160%);
      white-space: nowrap;
      pointer-events: none;
      border: 1px solid rgba(0, 123, 255, 0.3);  
      z-index: 1;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    /* Neural network animation canvas */
    #networkCanvas {
      width: 100%;
      height: 450px;
      background-color: #e9ecef;  
      border-radius: 12px;
      margin-top: 10px;
      border: 1px solid #dee2e6;
    }

    /* Bloom effect for neon glowing - May need adjustment for Light Mode */
    .bloom {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      mix-blend-mode: screen;  
      filter: blur(10px);  
      z-index: 1;
      opacity: 0.7;  
    }

    /* Controls for interactive chart */
    .chart-controls {
      display: flex;
      justify-content: center;
      margin-top: 10px;
      gap: 12px;
    }

    .chart-controls button {
      padding: 8px 15px;
      background-color: rgba(0, 123, 255, 0.08);  
      border: 1px solid rgba(0, 123, 255, 0.4);
      color: #007bff;  
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .chart-controls button:hover {
      background-color: rgba(0, 123, 255, 0.15);
      box-shadow: 0 0 10px rgba(0, 123, 255, 0.2);
    }
  </style>
</head>

<body>

  <div class="container">
    <div class="right-panel" id="viewer"></div>
    <div class="bloom" id="bloomEffect"></div>
  </div>

  <div id="overlay-buttons">
    <button onclick="LearningStart()">AI 학습</button>
    <button onclick="DemoStart()">데모 시작</button>
    <button onclick="LeakDetection()">AI 기반 누출 추정</button>
    <button onclick="Dispersion()">암모니아 확산 양상</button>
  </div>

  <div id="popup" class="ui-panel">
    <div id="popup-header">
      <span id="popupTitle">시뮬레이션 정보</span>
      <button id="closeButton" onclick="closePopup()">✖</button>
    </div>
    <div id="popup-content"></div>
  </div>

  <div id="graphModal" class="ui-panel">
    <button id="closeGraphButton" onclick="closeGraphModal()">✖</button>
    <h3 id="graphTitle">센서 시계열 데이터</h3>
    <div id="graphCanvasContainer">
      <canvas id="sensorChart"></canvas>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/postprocessing/ShaderPass.js"></script>

  <script>
    let scene, camera, renderer, loader, controls, currentModel, modelWireframe;  
    let composer, bloomPass;  
    const popup = document.getElementById('popup');
    const popupHeader = document.getElementById('popup-header');
    const popupTitleElement = document.getElementById('popupTitle');
    let popupLocked = true;  
    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    let isPlaying = true;

    if (!window.clickableCubes) window.clickableCubes = [];
    
    const sensorLabels = [];  
    const sensorObjects = {};  

    const INITIAL_CHART_SPEED_FACTOR = 60;  

    // Obstacles for dispersion simulation
    const obstacles = [
      { center: new THREE.Vector3(3.5, -1, 2), size: new THREE.Vector3(2, 10, 3) },
      { center: new THREE.Vector3(-0.4, -1, 2), size: new THREE.Vector3(2, 10, 3) },
      { center: new THREE.Vector3(-4.3, -1, 2), size: new THREE.Vector3(2, 10, 3) }
    ];

    // Initialize obstacle min/max values
    obstacles.forEach(obs => {
      const halfSize = obs.size.clone().multiplyScalar(0.5);
      obs.min = obs.center.clone().sub(halfSize);
      obs.max = obs.center.clone().add(halfSize);
    });

    // Dispersion variables
    let dispersionParticles = [];
    let dispersionGrid = {};  
    let dispersionAnimationId = null;
    let particleCreationIntervalId = null;
    const DISPERSION_GRID_SIZE = 0.75; // 그리드 셀 크기 조정 (더 세밀하게)
    const MAX_CONCENTRATION_VISUAL = 15; // 그리드 시각화 최대 농도 값 (조정 가능)
    let dispersionGroup = new THREE.Group();  
    const LOW_CONCENTRATION_COLOR = new THREE.Color(0x00ff00); // Green
    const MID_CONCENTRATION_COLOR = new THREE.Color(0xffff00); // Yellow
    const HIGH_CONCENTRATION_COLOR = new THREE.Color(0xff0000); // Red
    function closePopup() {
      // 폼 관련 애니메이션 중지
      if (leakTimer) {  
          clearInterval(leakTimer);
          leakTimer = null;
      }
      if (leakChart) {  
          leakChart.destroy();
          leakChart = null;
      }
      if (window.neuralNetAnimationId) {
        cancelAnimationFrame(window.neuralNetAnimationId);
        window.neuralNetAnimationId = null;
      }
      
      // 암모니아 확산 시뮬레이션의 경우는 팝업이 닫혀도 유지
      const isDispersionActive = dispersionAnimationId !== null;
      
      // 암모니아 확산 중이 아닐 때만 애니메이션 정리
      if (!isDispersionActive) {
        // Stop dispersion animation if active
        if (dispersionAnimationId) {
          cancelAnimationFrame(dispersionAnimationId);
          dispersionAnimationId = null;
        }
        if (particleCreationIntervalId) {
          clearInterval(particleCreationIntervalId);
          particleCreationIntervalId = null;
        }
        // Clear dispersion objects
        while(dispersionGroup.children.length > 0){  
            const object = dispersionGroup.children[0];
            if(object.geometry) object.geometry.dispose();
            if(object.material) {
                if(Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                } else {
                    object.material.dispose();
                }
            }
            dispersionGroup.remove(object);  
        }
        dispersionParticles = [];
        dispersionGrid = {};
      }
      
      // 기존 상태 큐브 제거
      ['GE#1', 'GE#2', 'GE#3'].forEach(cubeName => {
        const existingCube = scene.getObjectByName(cubeName);
        if (existingCube) {
          scene.remove(existingCube);
          if (existingCube.geometry) existingCube.geometry.dispose();
          if (existingCube.material) existingCube.material.dispose();
        }
      });
      
      popup.style.display = 'none';
      popupLocked = false;  
    }

    function closeGraphModal() {
        const graphModal = document.getElementById('graphModal');
        if (graphModal) {
            graphModal.style.display = 'none';
        }
    }
    
    init();
    loadModel('https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/model_GE-v1.glb');

    function init() {
      const container = document.getElementById('viewer');
      scene = new THREE.Scene();
      scene.add(dispersionGroup);  
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });  
      renderer.setSize(container.clientWidth, container.clientHeight);
      scene.background = new THREE.Color(0xddeeff);  
      container.appendChild(renderer.domElement);

      const aspect = container.clientWidth / container.clientHeight;
      const dist = 15;  
      camera = new THREE.OrthographicCamera(-dist * aspect, dist * aspect, dist, -dist, 0.1, 1000);
      camera.position.set(20, 20, 20);  
      camera.lookAt(0,0,0);


      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0,0,0);  
      controls.enableDamping = true;  
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 5;
      controls.maxDistance = 100;  
      controls.maxPolarAngle = Math.PI / 1.5;  
      controls.update();

      loader = new THREE.GLTFLoader();

      scene.add(new THREE.AmbientLight(0x777777, 0.5));  
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);  
      directionalLight.position.set(8, 15, 10);  
      directionalLight.castShadow = true;  
      scene.add(directionalLight);

      const keyLight = new THREE.PointLight(0xffffff, 0.3, 150);  
      keyLight.position.set(-15, 20, 15);
      scene.add(keyLight);

      const fillLight = new THREE.PointLight(0xaaaaff, 0.15, 100);  
      fillLight.position.set(15, 5, -15);
      scene.add(fillLight);
      
      setupBloom(container);
      
      addLabeledSensor(3.45, 1.11, -0.565, 'Sensor #1', 0.5);  
      addLabeledSensor(-0.507, 1.11, -0.565, 'Sensor #2', 0.5);
      addLabeledSensor(-4.46, 1.11, -0.565, 'Sensor #3', 0.5);
      addLabeledSensor(4.26, 1.11, 0.360, 'Sensor #4', 0.5);
      addLabeledSensor(0.304, 1.11, 0.360, 'Sensor #5', 0.5);
      addLabeledSensor(-3.65, 1.11, 0.360, 'Sensor #6', 0.5);
      
      addLeakPoint(3.0, 3.0, -1.0, 'Leak #1', 0.2);  
      addLeakPoint(-0.9, 3.0, -1.0, 'Leak #2', 0.2);
      addLeakPoint(-4.8, 3.0, -1.0, 'Leak #3', 0.2);
      addLeakPoint(4.5, -1.5, 2.0, 'Leak #4', 0.2);
      addLeakPoint(0.6, -1.5, 2.0, 'Leak #5', 0.2);
      addLeakPoint(-3.3, -1.5, 2.0, 'Leak #6', 0.2);
      addLeakPoint(4.5, 0.0, 2.0, 'Leak #7', 0.2);
      
      animate();
    }
    
    function setupBloom(container) {
      composer = new THREE.EffectComposer(renderer);
      
      const renderPass = new THREE.RenderPass(scene, camera);
      composer.addPass(renderPass);
      
      bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(container.clientWidth, container.clientHeight),
        0.1,    
        0.2,    
        0.2    
      );
      composer.addPass(bloomPass);

      const copyPass = new THREE.ShaderPass(THREE.CopyShader);
      copyPass.renderToScreen = true;
      composer.addPass(copyPass);
    }

    function loadModel(path) {
      if (currentModel) {  
        scene.remove(currentModel);
        currentModel.traverse(child => {
            if (child.isMesh) {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            }
        });
        currentModel = null;
      }
      if (modelWireframe) {  
          scene.remove(modelWireframe);
          modelWireframe.traverse(child => {
              if (child.isLineSegments) {  
                  if (child.geometry) child.geometry.dispose();
                  if (child.material) child.material.dispose();
              }
          });
          modelWireframe = null;
      }

      loader.load(path, function (gltf) {
        const originalModel = gltf.scene;
        modelWireframe = new THREE.Group();  

        originalModel.traverse(function(child) {
          if (child.isMesh) {
            const edges = new THREE.EdgesGeometry(child.geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x222222, linewidth: 1.5 });  
            const lineSegments = new THREE.LineSegments(edges, lineMaterial);
            
            lineSegments.position.copy(child.position);
            lineSegments.rotation.copy(child.rotation);
            lineSegments.scale.copy(child.scale);
            
            modelWireframe.add(lineSegments);
          }
        });
        
        const box = new THREE.Box3().setFromObject(modelWireframe);  
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        const maxDim = Math.max(size.x, size.y, size.z);
        let scaleFactor = 21.7;  
        let scale = 1;
        if (maxDim > 0) {  
            scale = scaleFactor / maxDim;  
        }
        
        modelWireframe.scale.set(scale, scale, scale);
        
        const scaledBox = new THREE.Box3().setFromObject(modelWireframe);
        const scaledCenter = scaledBox.getCenter(new THREE.Vector3());
        modelWireframe.position.sub(scaledCenter);  
        
        scene.add(modelWireframe);
        console.log("Model loaded as wireframe and added to scene.");
        console.log("Model scale applied:", scale, "Target size:", scaleFactor);
        console.log("Model dimensions after scaling (approx):", size.x * scale, size.y * scale, size.z * scale);


      }, undefined, function (error) {
        console.error('모델 로드 실패:', error);
        const viewer = document.getElementById('viewer');
        if(viewer) viewer.innerHTML = `<p style="color:red; text-align:center; padding-top: 20px;">3D 모델 로드에 실패했습니다. 경로를 확인해주세요: ${path}</p>`;
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();  
      
      updateSensorLabels();

      if (composer) {
        composer.render();
      } else {
        renderer.render(scene, camera);  
      }
    }

    function LearningStart() {
      popupLocked = true;
      popupTitleElement.textContent = "AI 학습 - 신경망 시각화";
      
      const html = `
        <div style="text-align: center;">
          <canvas id="networkCanvas"></canvas>
          <p style="margin-top: 14px; font-size: 1.3em; color: #333;">딥러닝 신경망 학습 진행 중...</p>
          <p style="font-size: 0.8em; color: #555;">복잡한 다층 신경망 구조가 학습 데이터를 처리하고 있습니다.</p>
        </div>
      `;

      document.getElementById('popup-content').innerHTML = html;
      popup.style.width = '40vw';  
      popup.style.maxWidth = '600px';
      popup.style.height = 'auto';  
      popup.style.maxHeight = '90vh';
      popup.style.bottom = 'auto';  
      popup.style.right = 'auto';
      popup.style.top = '50%';
      popup.style.left = '50%';
      popup.style.transform = 'translate(-50%, -50%)';  
      popup.style.display = 'block';
      
      setTimeout(initNeuralNetworkAnimation, 100);
    }
    
    function initNeuralNetworkAnimation() {
      const canvas = document.getElementById('networkCanvas');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      canvas.width = canvas.clientWidth;  
      canvas.height = canvas.clientHeight;
      
      const layers = [3, 6, 18, 18, 6, 3];  
      const neurons = [];
      const connections = [];
      
      const padding = Math.min(canvas.width, canvas.height) * 0.1;  
      const layerSpacing = (canvas.width - padding * 2) / (layers.length - 1);
      
      layers.forEach((neuronCount, layerIndex) => {
        const layerX = padding + layerIndex * layerSpacing;
        const neuronSpacing = (canvas.height - padding * 2) / (neuronCount +1);  
        
        for (let i = 1; i <= neuronCount; i++) {
          const neuronY = padding + i * neuronSpacing;
          neurons.push({
            x: layerX,
            y: neuronY,
            layer: layerIndex,
            index: i,
            radius: Math.max(3, Math.min(canvas.width, canvas.height) * 0.01),  
            activation: Math.random(),
            activationTarget: Math.random(),
            speed: 0.01 + Math.random() * 0.03
          });
        }
      });
      
      for (let l = 0; l < layers.length - 1; l++) {
        const layerNeurons = neurons.filter(n => n.layer === l);
        const nextLayerNeurons = neurons.filter(n => n.layer === l + 1);
        
        layerNeurons.forEach(from => {
          nextLayerNeurons.forEach(to => {
            connections.push({
              from: from,
              to: to,
              weight: Math.random() * 2 - 1,  
              signalPosition: 0,
              signalSpeed: 0.01 + Math.random() * 0.02,
              active: Math.random() > 0.7,  
              signal: false
            });
          });
        });
      }
      
      function animateNetwork() {  
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        connections.forEach(conn => {
          if (Math.random() < 0.01) conn.active = Math.random() > 0.3;
          
          if (conn.active) {
            conn.signalPosition += conn.signalSpeed;
            if (conn.signalPosition > 1) {
              conn.signalPosition = 0;
              conn.to.activationTarget = Math.min(1, conn.to.activationTarget + 0.3);
            }
          }
          
          ctx.beginPath();
          ctx.moveTo(conn.from.x, conn.from.y);
          ctx.lineTo(conn.to.x, conn.to.y);
          
          const alpha = conn.active ? 0.2 : 0.03;  
          const r = conn.weight > 0 ? 0 : 150;  
          const g = conn.weight > 0 ? 150 : 0;
          const b_val = 150;  
          
          ctx.strokeStyle = `rgba(${r}, ${g}, ${b_val}, ${alpha})`;
          ctx.lineWidth = Math.max(0.5, Math.abs(conn.weight) * 1.2);  
          ctx.stroke();
          
          if (conn.active) {
            const x = conn.from.x + (conn.to.x - conn.from.x) * conn.signalPosition;
            const y = conn.from.y + (conn.to.y - conn.from.y) * conn.signalPosition;
            
            ctx.beginPath();
            const current_neuron_radius = neurons.length > 0 && neurons[0].radius ? neurons[0].radius : 3;  
            ctx.arc(x, y, Math.max(2, current_neuron_radius * 0.3), 0, Math.PI * 2);  
            ctx.fillStyle = `rgba(0, 123, 255, 0.7)`;  
            ctx.fill();
            
          }
        });
        
        neurons.forEach(neuron => {
          neuron.activation += (neuron.activationTarget - neuron.activation) * neuron.speed;
          if (Math.random() < 0.01) neuron.activationTarget = Math.random();
          
          ctx.beginPath();
          ctx.arc(neuron.x, neuron.y, neuron.radius, 0, Math.PI * 2);
          
          const intensity = Math.floor(neuron.activation * 200) + 55;  
          ctx.fillStyle = `rgb(${intensity - 50 > 0 ? intensity - 50 : 0}, ${intensity - 20 > 0 ? intensity -20 : 0}, ${intensity})`;  
          ctx.fill();
          ctx.strokeStyle = `rgba(0, 100, 200, 0.5)`;  
          ctx.lineWidth = 1;
          ctx.stroke();

        });
        
        window.neuralNetAnimationId = requestAnimationFrame(animateNetwork);
      }
      
      animateNetwork();
    }

    let leakChart;
    let leakTimer;
    let leakData = [];
    let leakIndex = 0;
    let currentChartSpeedFactor = INITIAL_CHART_SPEED_FACTOR;  
    let currentLeakDetectionValueIndices = [];  

    function showChartPopup() {
        popup.style.width = '450px';  
        popup.style.height = '350px';  
        popup.style.bottom = '20px';
        popup.style.right = '20px';
        popup.style.top = 'auto';  
        popup.style.left = 'auto';
        popup.style.transform = 'none';
        popup.style.display = 'block';
    }   function DemoStart() {
      if (leakTimer) clearInterval(leakTimer);
      if (leakChart) leakChart.destroy();
      leakData = [];
      leakIndex = 0;
      popupLocked = false;  
      isPlaying = true;  
      popupTitleElement.textContent = "데모 데이터 시각화";
      currentChartSpeedFactor = INITIAL_CHART_SPEED_FACTOR;  
      currentLeakDetectionValueIndices = [];  
      
      // 기존 상태 큐브 제거
      ['GE#1', 'GE#2', 'GE#3'].forEach(cubeName => {
        const existingCube = scene.getObjectByName(cubeName);
        if (existingCube) {
          scene.remove(existingCube);
          if (existingCube.geometry) existingCube.geometry.dispose();
          if (existingCube.material) existingCube.material.dispose();
        }
      });

      // 로컬 데이터 로드
      const localDataPath = './sensor_data/scenario_7-1.csv';
      const backupDataPath = 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/leak_7.csv';
      
      fetch(localDataPath)
        .then(response => {
            if (!response.ok) {
                console.warn(`로컬 파일 '${localDataPath}' 로드 실패 (${response.status}), 대체 파일 사용: ${backupDataPath}`);
                return fetch(backupDataPath);
            }
            return response;
        })
        .catch(error => {
            console.warn(`로컬 파일 로드 중 오류 발생 (${error.message}), 대체 파일 사용: ${backupDataPath}`);
            return fetch(backupDataPath);
        })
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${response.url}`);
            return response.text();
        })
        .then(csvText => {
          const lines = csvText.trim().split('\n');
          const headerLineRaw = lines.shift();
          if (!headerLineRaw) throw new Error("CSV 파일이 비어 있거나 헤더가 없습니다.");

          const rawHeaders = headerLineRaw.split(',');
          const cleanedHeaders = rawHeaders.map(h => {
              const bracketEnd = h.indexOf(']');
              return (bracketEnd !== -1 && bracketEnd + 1 < h.length) ? h.substring(bracketEnd + 1).trim() : h.trim();
          });

          const timeIdx = cleanedHeaders.indexOf('Time (sec)');
          if (timeIdx === -1) {
              console.error("'Time (sec)' 컬럼을 찾을 수 없습니다. 헤더:", cleanedHeaders);
              throw new Error("'Time (sec)' 컬럼이 CSV에 없습니다.");
          }

          const valueIndices = cleanedHeaders
            .map((h, i) => ({ name: h, idx: i }))
            .filter(obj => obj.idx !== timeIdx && obj.name.startsWith("Sensor #"));

          if (valueIndices.length === 0) {
              console.error("'Sensor #' 컬럼을 찾을 수 없습니다. 정리된 헤더:", cleanedHeaders);
              throw new Error("플로팅할 'Sensor #' 컬럼이 없습니다.");
          }
          
          leakData = lines.map(line => {
              const parts = line.split(',');
              if (parts.length <= Math.max(timeIdx, ...valueIndices.map(v => v.idx))) {
                  console.warn(`잘못된 형식의 CSV 행 건너뛰기: ${line}`);
                  return null;  
              }
              const time = parseFloat(parts[timeIdx]);
              const values = valueIndices.map(obj => parseFloat(parts[obj.idx]));
              return { x: time, yValues: values };
          }).filter(item => item !== null);  


          document.getElementById('popup-content').innerHTML = `
            <canvas id="leakChartCanvas" style="width: 100%; height: calc(100% - 40px);"></canvas>  
            <div class="chart-controls">
              <button id="playPauseBtn">⏸️ 일시정지</button>
              <button id="resetBtn">⟲ 재시작</button>
              <button id="speedUpBtn">⏩ 속도 증가</button>
              <button id="speedDownBtn">⏪ 속도 감소</button>
            </div>`;
          
          showChartPopup();  

          const ctx = document.getElementById('leakChartCanvas').getContext('2d');
          leakChart = new Chart(ctx, {
            type: 'line',
            data: {
              datasets: valueIndices.map((obj, index) => ({
                label: obj.name,
                data: [],
                borderColor: `hsl(${(index * 60 + 180) % 360}, 60%, 45%)`,  
                backgroundColor: `hsla(${(index * 60 + 180) % 360}, 60%, 45%, 0.1)`,
                fill: false,
                tension: 0.2,
                borderWidth: 2
              }))
            },
            options: {
              animation: false,
              scales: {
                x: {
                  type: 'linear',
                  title: { display: true, text: 'Time [s]', color: '#333' },  
                  min: 0,
                  ticks: { color: '#555', font: {size: 10}},  
                  grid: { color: 'rgba(0,0,0,0.05)'}  
                },
                y: {
                  title: { display: true, text: 'NH3 [ppm]', color: '#333' },
                  min: 0,
                  ticks: { color: '#555', font: {size: 10}},  
                  grid: { color: 'rgba(0,0,0,0.05)'}
                }
              },
              plugins: {
                legend: { labels: { color: '#333', font: {size: 10} } }  
              },
              responsive: true,
              maintainAspectRatio: false  
            }
          });
          
          setupChartControls();  

          leakTimer = setInterval(() => {
            updateChartData(false);  
          }, 1000 / currentChartSpeedFactor);
        })
        .catch(error => {
          console.error("DemoStart CSV Error:", error);
          document.getElementById('popup-content').innerHTML = `<p style="color:red;">데모 CSV 로드 실패: ${error.message}</p>`;
          showChartPopup();
        });
    }   
    function LeakDetection() {
      if (leakTimer) clearInterval(leakTimer);
      if (leakChart) leakChart.destroy();
      leakData = [];
      leakIndex = 0;
      popupLocked = false;
      isPlaying = true;
      popupTitleElement.textContent = "AI 기반 누출 추정"; 
      currentChartSpeedFactor = INITIAL_CHART_SPEED_FACTOR; 
      currentLeakDetectionValueIndices = []; 
      
      // 기존 상태 큐브 제거
      ['GE#1', 'GE#2', 'GE#3'].forEach(cubeName => {
        const existingCube = scene.getObjectByName(cubeName);
        if (existingCube) {
          scene.remove(existingCube);
          if (existingCube.geometry) existingCube.geometry.dispose();
          if (existingCube.material) existingCube.material.dispose();
        }
      });
      
      // 상태 큐브 생성
      let statusCube1, statusCube2, statusCube3;
      const geometry = new THREE.BoxGeometry(2, 10, 3);
      
      statusCube1 = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }));
      statusCube2 = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }));
      statusCube3 = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }));

      statusCube1.position.set(3.5, -1, 2);
      statusCube2.position.set(-0.4, -1, 2);
      statusCube3.position.set(-4.3, -1, 2);

      statusCube1.name = 'GE#1';
      statusCube2.name = 'GE#2';
      statusCube3.name = 'GE#3';

      scene.add(statusCube1);
      scene.add(statusCube2);
      scene.add(statusCube3);

      // 누출원 선택기 UI 제거됨
      
      document.getElementById('popup-content').innerHTML = `
        <canvas id="leakChartCanvas" style="width: 100%; height: calc(100% - 60px);"></canvas> 
        <div class="chart-controls">
          <button id="playPauseBtn">⏸️ 일시정지</button>
          <button id="resetBtn">⟲ 재시작</button>
          <button id="speedUpBtn">⏩ 속도 증가</button>
          <button id="speedDownBtn">⏪ 속도 감소</button>
        </div>
        <div style="margin-top: 5px; text-align: center; font-size: 0.85em;">
          <span style="color: #2c3e50;">예상 좌표: (4.7, 2.1, 0.5) ±0.2m | 신뢰도: <span style="color: #28a745; font-weight: bold;">98.2%</span></span>
        </div>
      `;
      
      showChartPopup();
      
      // 누출원 선택 버튼 이벤트 리스너 제거됨
      
      // 기본값으로 Leak #7 로드
      loadLeakScenario(7);
    }   
    // 누출 시나리오 데이터 로드 함수
    function loadLeakScenario(leakNumber) {
      // Ensure leakNumber is treated as a number
      leakNumber = parseInt(leakNumber);
      console.log(`Loading leak scenario: ${leakNumber}`);
      
      if (leakTimer) clearInterval(leakTimer);
      if (leakChart) leakChart.destroy();
      leakData = [];
      leakIndex = 0;
      isPlaying = true;
      currentLeakDetectionValueIndices = [];
      
      // 로딩 상태 표시
      document.getElementById('popup-content').innerHTML = `
        <div style="text-align:center; padding: 20px;">
          <p>누출원 #${leakNumber} 데이터 로딩 중...</p>
          <div style="width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; margin: 10px auto; animation: spin 1s linear infinite;"></div>
        </div>
        <style>@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); }}</style>
      `;

      // 로컬 경로와 대체 경로 설정
      const localCsvFilePath = `./sensor_data/scenario_${leakNumber}-1.csv`;
      const backupCsvFilePath = `https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/leak_${leakNumber}.csv`;

      console.log(`Trying to load leak scenario #${leakNumber} from: ${localCsvFilePath}`);
      console.log(`Backup URL: ${backupCsvFilePath}`);
      
      // 로컬 파일 먼저 시도
      fetch(localCsvFilePath)
        .then(response => {
          if (!response.ok) {
            console.warn(`로컬 파일 '${localCsvFilePath}' 로드 실패 (${response.status}), 대체 파일 사용: ${backupCsvFilePath}`);
            return fetch(backupCsvFilePath);
          }
          return response;
        })
        .catch(error => {
          console.warn(`로컬 파일 로드 중 오류 발생 (${error.message}), 대체 파일 사용: ${backupCsvFilePath}`);
          return fetch(backupCsvFilePath);
        })
        .then(response => {
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${response.url}`);
          return response.text();
        })
        .then(csvText => {
          try {
            // 누출원 선택기 UI 업데이트 부분 제거
            
            const lines = csvText.trim().split('\n');
            const headerLineRaw = lines.shift();
            if (!headerLineRaw) throw new Error("CSV 파일이 비어 있거나 헤더가 없습니다.");

            const rawHeaders = headerLineRaw.split(',');
            const cleanedHeaders = rawHeaders.map(h => {
                const bracketEnd = h.indexOf(']');
                return (bracketEnd !== -1 && bracketEnd + 1 < h.length) ? h.substring(bracketEnd + 1).trim() : h.trim();
            });

            const timeIdx = cleanedHeaders.indexOf('Time (sec)');
            if (timeIdx === -1) {
                console.error("'Time (sec)' 컬럼을 찾을 수 없습니다. 헤더:", cleanedHeaders);
                throw new Error("'Time (sec)' 컬럼이 CSV에 없습니다.");
            }

            currentLeakDetectionValueIndices = cleanedHeaders
              .map((h, i) => ({ name: h, idx: i }))
              .filter(obj => obj.idx !== timeIdx && obj.name.startsWith("Sensor #"));

            if (currentLeakDetectionValueIndices.length === 0) {
                console.error("'Sensor #' 컬럼을 찾을 수 없습니다. 정리된 헤더:", cleanedHeaders);
                throw new Error("플로팅할 'Sensor #' 컬럼이 없습니다.");
            }

            leakData = lines.map(line => {
                const parts = line.split(',');
                if (parts.length <= Math.max(timeIdx, ...currentLeakDetectionValueIndices.map(v => v.idx))) {
                    console.warn(`잘못된 형식의 CSV 행 건너뛰기: ${line}`);
                    return null;
                }
                const time = parseFloat(parts[timeIdx]);
                const values = currentLeakDetectionValueIndices.map(obj => parseFloat(parts[obj.idx]));
                return { x: time, yValues: values };
            }).filter(item => item !== null);

            // 누출원 선택기 UI 및 차트 UI 생성 (선택기 부분 제거)
            document.getElementById('popup-content').innerHTML = `
              <canvas id="leakChartCanvas" style="width: 100%; height: calc(100% - 60px);"></canvas> 
              <div class="chart-controls">
                <button id="playPauseBtn">⏸️ 일시정지</button>
                <button id="resetBtn">⟲ 재시작</button>
                <button id="speedUpBtn">⏩ 속도 증가</button>
                <button id="speedDownBtn">⏪ 속도 감소</button>
              </div>
              <div style="margin-top: 5px; text-align: center; font-size: 0.85em;">
                <span style="color: #2c3e50;">예상 좌표: (4.7, 2.1, 0.5) ±0.2m | 신뢰도: <span style="color: #28a745; font-weight: bold;">98.2%</span></span>
              </div>
            `;
            
            // 누출원 선택 버튼 이벤트 리스너 추가 부분 제거
            
            // 차트 상태 초기화
            resetChartAndCubes();

            const chartCanvas = document.getElementById('leakChartCanvas');
            if (!chartCanvas) {
              throw new Error("차트 캔버스 요소를 찾을 수 없습니다.");
            }
            
            const ctx = chartCanvas.getContext('2d');
            if (!ctx) {
              throw new Error("차트 캔버스 컨텍스트를 초기화할 수 없습니다.");
            }
            
            leakChart = new Chart(ctx, {
              type: 'line',
              data: {
                datasets: currentLeakDetectionValueIndices.map((obj, index) => ({  
                  label: obj.name,
                  data: [],
                  borderColor: `hsl(${(index * 60 + 180) % 360}, 60%, 45%)`,
                  backgroundColor: `hsla(${(index * 60 + 180) % 360}, 60%, 45%, 0.1)`,
                  borderWidth: 2,  
                  pointRadius: 2,  
                  pointHoverRadius: 5,
                  fill: false,
                  tension: 0.2
                }))
              },
              options: {
                animation: false,
                scales: {
                  x: {
                    type: 'linear',
                    title: { display: true, text: 'Time [s]', color: '#333', font: { size: 10 } },
                    min: 0,
                    ticks: { color: '#555', font: {size: 9}},
                    grid: { color: 'rgba(0,0,0,0.05)'}
                  },
                  y: {
                    title: { display: true, text: 'Sensor Reading [ppm]', color: '#333', font: { size: 10 } },
                    min: 0,
                    ticks: { color: '#555', font: {size: 9}},
                    grid: { color: 'rgba(0,0,0,0.05)'}
                  }
                },
                plugins: {
                  legend: {  
                    labels: { color: '#333', font: { size: 9 } },
                    position: 'top'
                  },
                  tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',  
                    titleFont: { size: 12 },
                    bodyFont: { size: 10 },
                    titleColor: '#333',  
                    bodyColor: '#333',
                    borderColor: 'rgba(0, 123, 255, 0.3)',
                    borderWidth: 1
                  }
                },
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                  mode: 'index',
                  intersect: false
                }
              }
            });
            
            setupChartControls();

            leakTimer = setInterval(() => {
              updateChartData(true);  
            }, 1000 / currentChartSpeedFactor);
          } catch (err) {
            console.error("차트 초기화 오류:", err);
            document.getElementById('popup-content').innerHTML = `
              <div style="text-align: center; color: #dc3545; padding: 15px 10px;">
                <p style="font-weight: bold;">차트 초기화 실패</p>
                <p style="font-size: 0.9em; margin-top: 10px;">${err.message}</p>
                <button id="retryBtn" style="margin-top: 10px; padding: 5px 10px; background-color: rgba(0, 123, 255, 0.1); border: 1px solid rgba(0, 123, 255, 0.5); color: #007bff; border-radius: 4px; cursor: pointer;">
                  다시 시도
                </button>
              </div>
            `;
            
            // 다시 시도 버튼에 이벤트 리스너 추가
            document.getElementById('retryBtn').addEventListener('click', function() {
              loadLeakScenario(leakNumber);
            });
          }
        })
        .catch(error => {
          console.error(`Leak #${leakNumber} 시나리오 데이터 로드 오류:`, error);
          document.getElementById('popup-content').innerHTML = `
            <div style="text-align: center; color: #dc3545; padding: 15px 10px;">
              <p style="font-weight: bold;">데이터 로드 실패</p>
              <p style="font-size: 0.9em; margin-top: 10px;">${error.message}</p>
              <button id="defaultDataBtn" style="margin-top: 10px; padding: 5px 10px; background-color: rgba(0, 123, 255, 0.1); border: 1px solid rgba(0, 123, 255, 0.5); color: #007bff; border-radius: 4px; cursor: pointer;">
                기본 데이터로 보기
              </button>
            </div>
          `;
          
          // 기본 데이터로 보기 버튼에 이벤트 리스너 추가
          document.getElementById('defaultDataBtn').addEventListener('click', function() {
            loadLeakScenario(7);
          });
        });
    }   
    function resetChartAndCubes() {
      // Reset chart data
      if (leakChart) {
        leakChart.data.datasets.forEach(dataset => {
          dataset.data = [];
        });
        leakChart.options.scales.x.min = 0;  
        if (leakData.length > 0) {
          leakChart.options.scales.x.max = leakData[0].x + 1;  
        } else {
          leakChart.options.scales.x.max = 1;
        }
        leakChart.update('none');
      }
      
      // Reset sensor colors
      sensorLabels.forEach(sl => {
        if (sl.mesh && sl.mesh.userData.name && sl.mesh.userData.name.startsWith("Sensor #")) {  
          sl.mesh.material.color.set(0x007bff);  
          sl.mesh.material.emissive.set(0x004499);
          sl.mesh.material.opacity = 0.7;  
          sl.mesh.material.emissiveIntensity = 0.2;  
        }
      });
      
      // Reset cube colors
      ['GE#1', 'GE#2', 'GE#3'].forEach(cubeName => {
        const cube = scene.getObjectByName(cubeName);
        if (cube) {
          cube.material.color.set(0x00ff00); // Reset to green
          cube.material.opacity = 0.5;
          // Reset smoothing cache
          if (typeof prevCubeColors !== 'undefined') {
            prevCubeColors[cubeName] = new THREE.Color(0x00ff00);
            prevCubeOpacities[cubeName] = 0.5;
          }
        }
      });
      
      leakIndex = 0;
      isPlaying = true;
      if(document.getElementById('playPauseBtn')) {
        document.getElementById('playPauseBtn').textContent = "⏸️ 일시정지";
      }
    }

    function setupChartControls() {
        const playPauseBtn = document.getElementById('playPauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const speedUpBtn = document.getElementById('speedUpBtn');
        const speedDownBtn = document.getElementById('speedDownBtn');

        let isLeakDetectionMode = currentLeakDetectionValueIndices.length > 0;  

        if (playPauseBtn) {
            playPauseBtn.onclick = function() {
                isPlaying = !isPlaying;
                this.textContent = isPlaying ? "⏸️ 일시정지" : "▶️ 재생";
            };
        }
        if (resetBtn) {
            resetBtn.onclick = function() {
                resetChartAndCubes();
            };
        }
        if (speedUpBtn) {
            speedUpBtn.onclick = function() {
                currentChartSpeedFactor = Math.min(currentChartSpeedFactor * 1.5, 60);  
                if(leakTimer) clearInterval(leakTimer);
                leakTimer = setInterval(() => updateChartData(isLeakDetectionMode), 1000 / currentChartSpeedFactor);
            };
        }
        if (speedDownBtn) {
            speedDownBtn.onclick = function() {
                currentChartSpeedFactor = Math.max(currentChartSpeedFactor / 1.5, 1);  
                if(leakTimer) clearInterval(leakTimer);
                leakTimer = setInterval(() => updateChartData(isLeakDetectionMode), 1000 / currentChartSpeedFactor);
            };
        }
    }   // 레퍼런스 값 저장 (스무딩을 위한 이전 상태 저장)
    let prevCubeColors = {
      'GE#1': new THREE.Color(0x00ff00),
      'GE#2': new THREE.Color(0x00ff00),
      'GE#3': new THREE.Color(0x00ff00)
    };
    
    let prevCubeOpacities = {
      'GE#1': 0.5,
      'GE#2': 0.5,
      'GE#3': 0.5
    };
    
    function updateChartData(isLeakDetectionMode = false) {  
        if (isPlaying && leakIndex < leakData.length) {
            const point = leakData[leakIndex];
            if (point) {  
                point.yValues.forEach((val, chartDatasetIndex) => {  
                    if(leakChart && leakChart.data.datasets[chartDatasetIndex]) {  
                        leakChart.data.datasets[chartDatasetIndex].data.push({ x: point.x, y: val });
                    }                  if (isLeakDetectionMode && currentLeakDetectionValueIndices[chartDatasetIndex]) {
                        const sensorName = currentLeakDetectionValueIndices[chartDatasetIndex].name;
                        const sensorObject = sensorObjects[sensorName];  

                        if (sensorObject) {
                            // 더 낮은 값을 기준으로 색상 변화 범위 확장 (이전: 50, 현재: 10)
                            const MAX_PPM_FOR_COLOR = 10; // 더 작은 값으로 변경하여 더 낮은 값에서도 색상 변화가 드러나도록 함
                            const normalizedValue = Math.min(Math.max(val, 0) / MAX_PPM_FOR_COLOR, 1.0);
                            
                            // 3단계 색상 변화 구현 (파란색 → 노란색 → 빨간색)
                            let finalColor, finalEmissive, finalOpacity, finalEmissiveIntensity;
                            
                            if (normalizedValue < 0.5) {
                                // 낮은 값: 파란색 → 노란색 (0-50%)
                                const t = normalizedValue * 2; // 0-1 range
                                const lowColor = new THREE.Color(0x007bff); // 파란색
                                const midColor = new THREE.Color(0xffff00); // 노란색
                                
                                const lowEmissive = new THREE.Color(0x004499);
                                const midEmissive = new THREE.Color(0x884400);
                                
                                finalColor = new THREE.Color().lerpColors(lowColor, midColor, t);
                                finalEmissive = new THREE.Color().lerpColors(lowEmissive, midEmissive, t);
                                finalOpacity = 0.7 + t * 0.2; // 불투명도 증가
                                finalEmissiveIntensity = 0.3 + t * 0.7; // 발광 강도 증가
                            } else {
                                // 높은 값: 노란색 → 빨간색 (50-100%)
                                const t = (normalizedValue - 0.5) * 2; // 0-1 range
                                const midColor = new THREE.Color(0xffff00); // 노란색
                                const highColor = new THREE.Color(0xff0000); // 빨간색
                                
                                const midEmissive = new THREE.Color(0x884400);
                                const highEmissive = new THREE.Color(0xff0000);
                                
                                finalColor = new THREE.Color().lerpColors(midColor, highColor, t);
                                finalEmissive = new THREE.Color().lerpColors(midEmissive, highEmissive, t);
                                finalOpacity = 0.9 + t * 0.1; // 더 높은 불투명도
                                finalEmissiveIntensity = 1.0 + t * 1.5; // 더 강한 발광
                            }
                            
                            // 색상 적용
                            sensorObject.material.color.copy(finalColor);
                            sensorObject.material.emissive.copy(finalEmissive);
                            sensorObject.material.opacity = finalOpacity;
                            sensorObject.material.emissiveIntensity = finalEmissiveIntensity;
                            
                            // 활성화된 센서는 크기를 더 키워서 더 두드러지게 표시
                            if (normalizedValue > 0.1) {
                                const scale = 1.0 + normalizedValue * 1.0; // 크기 증가 강화
                                sensorObject.scale.set(scale, scale, scale);
                            } else {
                                sensorObject.scale.set(1, 1, 1);
                            }
                        }
                    }
                });
                
                // Update status cubes color when in leak detection mode
                if (isLeakDetectionMode) {
                    // Find objects by name
                    const statusCube1 = scene.getObjectByName('GE#1');
                    const statusCube2 = scene.getObjectByName('GE#2');
                    const statusCube3 = scene.getObjectByName('GE#3');
                    
                    if (point.yValues.length >= 3 && statusCube1 && statusCube2 && statusCube3) {
                        // Find max value and its index
                        const values = [point.yValues[0], point.yValues[1], point.yValues[2]];
                        const maxValue = Math.max(...values);
                        const maxIndex = values.indexOf(maxValue);
                        const SIGNIFICANT_THRESHOLD = 0.3; // 임계값 - 이 값 이상일 때만 빨간색으로 표시
                        
                        // Update each cube color based on its value and whether it's the max
                        const cubes = [statusCube1, statusCube2, statusCube3];
                        const cubeNames = ['GE#1', 'GE#2', 'GE#3'];
                        
                        // 각 큐브 색상과 투명도 부드럽게 업데이트
                        values.forEach((value, index) => {
                            // Calculate normalized value for color gradient (0-1 range)
                            const normalizedValue = Math.min(value, 1.0);
                            
                            // 타겟 색상과 투명도 계산
                            let targetColor = new THREE.Color();
                            let targetOpacity = 0.5;
                            
                            if (index === maxIndex && value > SIGNIFICANT_THRESHOLD) {
                                // 최대값을 가진 큐브만 빨간색으로 표시 (임계값 이상일 때)
                                targetColor.setRGB(1.0, 0, 0);
                                targetOpacity = 0.8;
                            } else {
                                // 나머지는 값에 따라 초록색에서 노란색 사이의 그라데이션
                                const green = 1.0; // 항상 녹색 성분 유지
                                const red = normalizedValue * 0.8; // 빨간색 성분은 값에 비례
                                targetColor.setRGB(red, green, 0);
                                targetOpacity = 0.5 + normalizedValue * 0.3;
                            }
                            
                            // 스무딩 계수 (0에 가까울수록 더 느리게 변화, 1에 가까울수록 즉시 변화)
                            const SMOOTHING_FACTOR = 0.1;
                            
                            // 현재 색상과 이전 색상 사이에 스무딩 적용
                            const cubeName = cubeNames[index];
                            const currentColor = prevCubeColors[cubeName] || new THREE.Color(0x00ff00);
                            const currentOpacity = prevCubeOpacities[cubeName] || 0.5;
                            
                            // 색상 보간
                            const r = currentColor.r + (targetColor.r - currentColor.r) * SMOOTHING_FACTOR;
                            const g = currentColor.g + (targetColor.g - currentColor.g) * SMOOTHING_FACTOR;
                            const b = currentColor.b + (targetColor.b - currentColor.b) * SMOOTHING_FACTOR;
                            
                            // 투명도 보간
                            const opacity = currentOpacity + (targetOpacity - currentOpacity) * SMOOTHING_FACTOR;
                            
                            // 계산된 값 적용
                            cubes[index].material.color.setRGB(r, g, b);
                            cubes[index].material.opacity = opacity;
                            
                            // 이전 값 업데이트
                            prevCubeColors[cubeName] = new THREE.Color(r, g, b);
                            prevCubeOpacities[cubeName] = opacity;
                        });
                    }
                }
                
                if (leakChart && leakData[leakIndex]) {  
                    leakChart.options.scales.x.max = leakData[leakIndex].x + 1;
                }
                if (leakChart) leakChart.update('none');
            }
            leakIndex++;
        } else if (leakIndex >= leakData.length) {
            // if(leakTimer) clearInterval(leakTimer);
        }
    }   function Dispersion() {
      // 이전 확산 관련 객체들 정리
      if (dispersionAnimationId) {
        cancelAnimationFrame(dispersionAnimationId);
        dispersionAnimationId = null;
      }
      if (particleCreationIntervalId) {
        clearInterval(particleCreationIntervalId);
        particleCreationIntervalId = null;
      }
      // dispersionGroup에 포함된 모든 자식 객체 제거 및 해제
      while(dispersionGroup.children.length > 0){  
        const object = dispersionGroup.children[0];
        if(object.geometry) object.geometry.dispose();
        if(object.material) {
            if(Array.isArray(object.material)) {
                object.material.forEach(material => material.dispose());
            } else {
                object.material.dispose();
            }
        }
        dispersionGroup.remove(object);  
      }
      dispersionParticles = [];
      dispersionGrid = {};      
      
      popupLocked = false;  
      popupTitleElement.textContent = "암모니아 확산 양상";
      document.getElementById('popup-content').innerHTML = `
        <p style="text-align:center; color: #333;">3D 뷰에서 암모니아 확산 시뮬레이션이 표시됩니다.</p>
        <p style="text-align:center; font-size:0.9em; color: #555;">팝업을 닫아도 시뮬레이션이 계속됩니다.</p>
      `;
      popup.style.width = '300px';  
      popup.style.height = 'auto';  
      popup.style.bottom = '20px';
      popup.style.right = '20px';
      popup.style.top = 'auto';  
      popup.style.left = 'auto';
      popup.style.transform = 'none';
      popup.style.display = 'block';

      // 확산 범위를 모델 크기에 맞게 정확하게 계산
      let worldBox = {  
          min: new THREE.Vector3(-10, -5, -5),
          max: new THREE.Vector3(10, 10, 5)
      };
      
      // 모델 Bounding Box 계산 - 더 정확하게 계산
      if (modelWireframe && modelWireframe.children.length > 0) {
          const modelBoundingBox = new THREE.Box3().setFromObject(modelWireframe);
          const modelSize = modelBoundingBox.getSize(new THREE.Vector3());
          const modelCenter = modelBoundingBox.getCenter(new THREE.Vector3());
          
          console.log("Model dimensions:", modelSize);
          console.log("Model center:", modelCenter);
          
          // 실제 모델 bounds를 사용하되, 약간의 여유 공간 추가
          worldBox.min = new THREE.Vector3(
              modelBoundingBox.min.x - modelSize.x * -0.05,
              modelBoundingBox.min.y - modelSize.y * -0.05,
              modelBoundingBox.min.z - modelSize.z * -0.05
          );
          worldBox.max = new THREE.Vector3(
              modelBoundingBox.max.x + modelSize.x * -0.05,
              modelBoundingBox.max.y + modelSize.y * -0.05,
              modelBoundingBox.max.z + modelSize.z * -0.05
          );
          
          console.log("Dispersion world box:", worldBox);
      } else {
          console.warn("Dispersion: modelWireframe not ready for bounding box calculation. Using default worldBox.");
      }
      
      // 누출원 위치 - 장애물 및 모델 크기에 맞게 조정
      const obstaclePositions = obstacles.map(obs => obs.center);
      const leakSource = new THREE.Vector3(
          obstaclePositions[0].x + 1.3, // 첫 번째 장애물(GE#1)보다 약간 오른쪽
          obstaclePositions[0].y + 3.0, // 높이 조정
          obstaclePositions[0].z - 1.6  // 앞쪽으로 조정
      );
      
      // 누출 표시 구체 생성
      const sourceMark = new THREE.Mesh(
        new THREE.SphereGeometry(0.25, 16, 16),
        new THREE.MeshStandardMaterial({  
          color: 0xff0000,  
          emissive: 0xdd0000,  
          emissiveIntensity: 1.0
        })
      );
      sourceMark.position.copy(leakSource);
      dispersionGroup.add(sourceMark);  

      // 파티클 설정 - 모델 크기에 맞게 조정
      const maxParticles = 2000; // 충분한 파티클 수 유지
      const particleInterval = 40; // 파티클 생성 간격 (ms)
      const particleBaseSpeed = 0.08; // 기본 속도
      const particleMaxAge = 140.0; // 파티클 수명
      const simplex = new SimplexNoise();  

      // 그리드 설정 - 좀 더 세밀하게 조정
      const gridCellSize = DISPERSION_GRID_SIZE;  
      const gridBaseMaterial = new THREE.MeshStandardMaterial({
          transparent: true,  
          opacity: 0.0  
      });
      const gridGeometry = new THREE.BoxGeometry(gridCellSize, gridCellSize, gridCellSize);
      
      // 파티클 생성 함수
      function createParticle() {
        let particlePosition = new THREE.Vector3();
        particlePosition.copy(leakSource).add(
            new THREE.Vector3(
                (Math.random() - 0.5) * 0.6,  
                (Math.random() - 0.5) * 0.6,  
                (Math.random() - 0.5) * 0.6
            )
        );

        // 모델 크기에 맞게 속도 벡터 조정
        const initialVelocity = new THREE.Vector3(
          (Math.random() - 0.5) * 2.5,  
          (Math.random() - 0.5) * 2.0 + 0.3, // 약간 위쪽으로 향하는 경향
          (Math.random() - 0.5) * 2.5
        ).normalize().multiplyScalar(particleBaseSpeed * (1 + Math.random() * 0.8));

        const material = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(Math.random() * 0.1, 1, 0.55), // 약간의 색상 변화
          transparent: true,
          opacity: 0.8 + Math.random() * 0.2
        });

        // 파티클 크기 랜덤화 - 모델 크기에 맞게 조정
        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(0.05 + Math.random() * 0.05, 5, 5),  
          material
        );
        particle.position.copy(particlePosition);
        particle.userData = {
          velocity: initialVelocity,
          age: 0,
          maxAge: particleMaxAge * (0.7 + Math.random() * 0.6)  
        };
        dispersionGroup.add(particle);  
        dispersionParticles.push(particle);
      }
      
      // 파티클 정기적 생성  
      particleCreationIntervalId = setInterval(() => {
        if (dispersionParticles.length < maxParticles +1) {  
            for(let i=0; i < 20; i++) createParticle();
        }
      }, particleInterval);

      // 그리드 키 생성 함수  
      function getGridKey(position) {
          const gx = Math.floor(position.x / gridCellSize);
          const gy = Math.floor(position.y / gridCellSize);
          const gz = Math.floor(position.z / gridCellSize);
          return `${gx}_${gy}_${gz}`;
      }
      
      // 애니메이션 함수  
      function animateDispersionInternal() {  
        dispersionAnimationId = requestAnimationFrame(animateDispersionInternal);
        const time = Date.now() * 0.0005;  

        // 그리드 농도 감소
        for (const key in dispersionGrid) {
            if (dispersionGrid[key].mesh) {
                dispersionGrid[key].concentration *= 0.95;  
                if(dispersionGrid[key].concentration < 0.05) dispersionGrid[key].concentration = 0;
            }
        }

        // 파티클 업데이트
        for (let i = dispersionParticles.length - 1; i >= 0; i--) {
          const p = dispersionParticles[i];
          if (p === sourceMark) continue;  

          // 난기류 시뮬레이션  
          const turbulenceScale = 0.25;  
          const noiseSpeed = 0.6;   
          const turbulenceStrength = 0.004;
          p.userData.velocity.x += simplex.noise3D(p.position.x * turbulenceScale, p.position.y * turbulenceScale, time * noiseSpeed) * turbulenceStrength;
          p.userData.velocity.y += simplex.noise3D(p.position.y * turbulenceScale, p.position.z * turbulenceScale, time * noiseSpeed) * (turbulenceStrength * 0.8);
          p.userData.velocity.z += simplex.noise3D(p.position.z * turbulenceScale, p.position.x * turbulenceScale, time * noiseSpeed) * turbulenceStrength;
          
          p.userData.velocity.clampLength(0, particleBaseSpeed * 2.5);

          // 다음 위치 계산  
          const nextPos = p.position.clone().add(p.userData.velocity);

          // 외부 박스 경계 충돌  
          if (nextPos.x < worldBox.min.x || nextPos.x > worldBox.max.x) {p.userData.velocity.x *= -0.4; nextPos.x = p.position.x;}
          if (nextPos.y < worldBox.min.y || nextPos.y > worldBox.max.y) {p.userData.velocity.y *= -0.4; nextPos.y = p.position.y;}
          if (nextPos.z < worldBox.min.z || nextPos.z > worldBox.max.z) {p.userData.velocity.z *= -0.4; nextPos.z = p.position.z;}
          
          // 장애물 충돌 검사 및 반응  
          for (const obs of obstacles) {
            const obsMin = obs.min.clone().subScalar(0.15);  
            const obsMax = obs.max.clone().addScalar(0.15);
            if (nextPos.x > obsMin.x && nextPos.x < obsMax.x &&
                nextPos.y > obsMin.y && nextPos.y < obsMax.y &&
                nextPos.z > obsMin.z && nextPos.z < obsMax.z) {
                p.position.sub(p.userData.velocity.clone().multiplyScalar(0.5));
                p.userData.velocity.multiplyScalar(-0.2);  
                break;  
            }
          }

          // 위치 업데이트  
          p.position.add(p.userData.velocity);
          p.userData.age += 1;  
          
          // 수명에 따른 시각적 효과  
          const lifeRatio = p.userData.age / p.userData.maxAge;
          
          p.material.opacity = Math.max(0, (1 - lifeRatio) * 0.6);  
          p.scale.setScalar(1 + lifeRatio * 2.0);  
          p.material.color.setHSL(0, 1, 0.5 + lifeRatio * 0.3);

          // 그리드 농도에 기여  
          const gridKey = getGridKey(p.position);
          if (!dispersionGrid[gridKey]) {
              dispersionGrid[gridKey] = { concentration: 0, mesh: null };
          }
          dispersionGrid[gridKey].concentration += 0.8;

          // 수명이 다한 파티클 제거
          if (p.userData.age > p.userData.maxAge) {
            dispersionGroup.remove(p);  
            if(p.geometry) p.geometry.dispose();
            if(p.material) p.material.dispose();
            dispersionParticles.splice(i, 1);
          }
        }

        // 그리드 시각화 업데이트  
        for (const key in dispersionGrid) {
            const cell = dispersionGrid[key];
            if (cell.concentration > 0.2) {  
                if (!cell.mesh) {
                    cell.mesh = new THREE.Mesh(gridGeometry, gridBaseMaterial.clone());
                    const [gx, gy, gz] = key.split('_').map(Number);
                    cell.mesh.position.set(
                        gx * gridCellSize + gridCellSize / 2,
                        gy * gridCellSize + gridCellSize / 2,
                        gz * gridCellSize + gridCellSize / 2
                    );
                    dispersionGroup.add(cell.mesh);
                }
                const concentrationRatio = Math.min(cell.concentration / MAX_CONCENTRATION_VISUAL, 1.0);
                cell.mesh.material.opacity = concentrationRatio * 0.4;  
                
                // 농도에 따른 색상 변화
                if (concentrationRatio < 0.25) {
                    cell.mesh.material.color.lerpColors(new THREE.Color(0x0000ff), LOW_CONCENTRATION_COLOR, concentrationRatio / 0.25);
                } else if (concentrationRatio < 0.5) {
                    cell.mesh.material.color.lerpColors(LOW_CONCENTRATION_COLOR, MID_CONCENTRATION_COLOR, (concentrationRatio - 0.25) / 0.25);
                } else if (concentrationRatio < 0.75) {
                    cell.mesh.material.color.lerpColors(MID_CONCENTRATION_COLOR, new THREE.Color(0xffa500), (concentrationRatio - 0.5) / 0.25);
                } else {
                    cell.mesh.material.color.lerpColors(new THREE.Color(0xffa500), HIGH_CONCENTRATION_COLOR, (concentrationRatio - 0.75) / 0.25);
                }

            } else if (cell.mesh) {
                dispersionGroup.remove(cell.mesh);
                if(cell.mesh.geometry) cell.mesh.geometry.dispose();
                if(cell.mesh.material) cell.mesh.material.dispose();
                cell.mesh = null;
            }
        }
      }
      
      // 애니메이션 시작
      animateDispersionInternal();
    }

    let isDragging = false, dragOffsetX = 0, dragOffsetY = 0;  

    popupHeader.addEventListener('mousedown', (e) => {
      if (e.target.id === 'closeButton' || (e.target.parentElement && e.target.parentElement.id === 'closeButton')) return;  
      isDragging = true;
      const rect = popup.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;
      popup.style.userSelect = 'none';  
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        let newX = e.clientX - dragOffsetX;
        let newY = e.clientY - dragOffsetY;
        const popupRect = popup.getBoundingClientRect();
        const bodyRect = document.body.getBoundingClientRect();

        if (newX < 0) newX = 0;
        if (newY < 0) newY = 0;
        if (newX + popupRect.width > bodyRect.width) newX = bodyRect.width - popupRect.width;
        if (newY + popupRect.height > bodyRect.height) newY = bodyRect.height - popupRect.height;
        
        popup.style.left = newX + 'px';
        popup.style.top = newY + 'px';
        popup.style.bottom = 'auto';  
        popup.style.right = 'auto';
        popup.style.transform = 'none';  
      }
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        popup.style.userSelect = 'auto';
      }
    });

    window.addEventListener('resize', () => {
      const container = document.getElementById('viewer');
      if (camera && renderer && container && container.clientWidth > 0 && container.clientHeight > 0) {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        if (composer) composer.setSize(container.clientWidth, container.clientHeight);
      }
    });     
    

    function addLabeledSensor(x, y, z, name, size = 0.5) {  
      const geometry = new THREE.BoxGeometry(size, size, size);  
      const material = new THREE.MeshStandardMaterial({
        color: 0x007bff,  
        emissive: 0x004499,  
        emissiveIntensity: 0.2,  
        transparent: true,
        opacity: 0.7  
      });
      
      const sensor = new THREE.Mesh(geometry, material);
      sensor.position.set(x, y, z);
      sensor.userData.name = name;  
      scene.add(sensor);
      sensorObjects[name] = sensor;  
      
      const labelDiv = document.createElement('div');
      labelDiv.className = 'sensor-label';
      labelDiv.textContent = name;
      document.body.appendChild(labelDiv);  
      sensorLabels.push({mesh: sensor, div: labelDiv});
    }

    function updateSensorLabels() {
        sensorLabels.forEach(item => {
            const tempV = new THREE.Vector3();
            item.mesh.getWorldPosition(tempV);
            tempV.project(camera);  

            const x = (tempV.x * .5 + .5) * renderer.domElement.clientWidth;
            const y = (tempV.y * -.5 + .5) * renderer.domElement.clientHeight;

            item.div.style.left = `${x}px`;
            item.div.style.top = `${y}px`;

            const distance = item.mesh.position.distanceTo(camera.position);
            if (tempV.z > 1 || distance > 50) {  
                item.div.style.display = 'none';
            } else {
                item.div.style.display = 'block';
            }
        });
    }
      function addLeakPoint(x, y, z, name, size = 0.2) {  
      const geometry = new THREE.SphereGeometry(size, 16, 16);
      const material = new THREE.MeshStandardMaterial({  
        color: 0xdc3545,  
        emissive: 0xaa2230,  
        emissiveIntensity: 0.4,  
        transparent: true,
        opacity: 0.85  
      });
      
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.set(x, y, z);
      sphere.userData.name = name;
      sphere.userData.leakNumber = parseInt(name.split('#')[1]);
      console.log(`Created leak point: ${name}, leakNumber: ${sphere.userData.leakNumber}`);
      scene.add(sphere);
      
      // 클릭 가능한 큐브 목록에 추가
      if (!window.clickableCubes) window.clickableCubes = [];
      window.clickableCubes.push(sphere);
      
      const labelDiv = document.createElement('div');
      labelDiv.className = 'sensor-label';  
      labelDiv.textContent = name;
      labelDiv.style.color = '#dc3545';  
      labelDiv.style.borderColor = 'rgba(220, 53, 69, 0.4)';
      document.body.appendChild(labelDiv);
      sensorLabels.push({mesh: sphere, div: labelDiv});  
    }
      function displayScenarioData(leakNumber) {
      if (leakTimer) clearInterval(leakTimer);
      if (leakChart) leakChart.destroy();
      leakData = [];
      leakIndex = 0;
      popupLocked = false;  
      isPlaying = true;
      popupTitleElement.textContent = `Leak #${leakNumber} 시나리오`;  
      currentChartSpeedFactor = INITIAL_CHART_SPEED_FACTOR;  
      currentLeakDetectionValueIndices = [];  
      
      // 로딩 상태 표시
      document.getElementById('popup-content').innerHTML = `
        <div style="text-align:center; padding: 20px;">
          <p>누출원 #${leakNumber} 데이터 로딩 중...</p>
          <div style="width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; margin: 10px auto; animation: spin 1s linear infinite;"></div>
        </div>
        <style>@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); }}</style>
      `;
      
      showChartPopup();
        // 로컬 경로와 대체 경로 설정
      const localCsvFilePath = `./sensor_data/scenario_${leakNumber}-1.csv`;
      const backupCsvFilePath = `https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/leak_${leakNumber}.csv`;

      console.log(`Trying to load leak scenario #${leakNumber} from: ${localCsvFilePath}`);
      console.log(`Backup URL: ${backupCsvFilePath}`);
      
      // 로컬 파일 먼저 시도
      fetch(localCsvFilePath)
        .then(response => {
          if (!response.ok) {
            console.warn(`로컬 파일 '${localCsvFilePath}' 로드 실패 (${response.status}), 대체 파일 사용: ${backupCsvFilePath}`);
            return fetch(backupCsvFilePath);
          }
          return response;
        })
        .catch(error => {
          console.warn(`로컬 파일 로드 중 오류 발생 (${error.message}), 대체 파일 사용: ${backupCsvFilePath}`);
          return fetch(backupCsvFilePath);
        })
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${response.url}`);
            return response.text();
        })
        .then(csvText => {
          const lines = csvText.trim().split('\n');
          const headerLineRaw = lines.shift();
          if (!headerLineRaw) throw new Error("CSV 파일이 비어 있거나 헤더가 없습니다.");

          const rawHeaders = headerLineRaw.split(',');
          const cleanedHeaders = rawHeaders.map(h => {
              const bracketEnd = h.indexOf(']');
              return (bracketEnd !== -1 && bracketEnd + 1 < h.length) ? h.substring(bracketEnd + 1).trim() : h.trim();
          });

          const timeIdx = cleanedHeaders.indexOf('Time (sec)');
          if (timeIdx === -1) {
              console.error("'Time (sec)' 컬럼을 찾을 수 없습니다. 헤더:", cleanedHeaders);
              throw new Error("'Time (sec)' 컬럼이 CSV에 없습니다.");
          }

          currentLeakDetectionValueIndices = cleanedHeaders
            .map((h, i) => ({ name: h, idx: i }))
            .filter(obj => obj.idx !== timeIdx && obj.name.startsWith("Sensor #"));

          if (currentLeakDetectionValueIndices.length === 0) {
              console.error("'Sensor #' 컬럼을 찾을 수 없습니다. 정리된 헤더:", cleanedHeaders);
              throw new Error("플로팅할 'Sensor #' 컬럼이 없습니다.");
          }
          
          leakData = lines.map(line => {
              const parts = line.split(',');
              if (parts.length <= Math.max(timeIdx, ...currentLeakDetectionValueIndices.map(v => v.idx))) {
                  console.warn(`잘못된 형식의 CSV 행 건너뛰기: ${line}`);
                  return null;  
              }
              const time = parseFloat(parts[timeIdx]);
              const values = currentLeakDetectionValueIndices.map(obj => parseFloat(parts[obj.idx]));
              return { x: time, yValues: values };
          }).filter(item => item !== null);


          document.getElementById('popup-content').innerHTML = `
            <canvas id="leakChartCanvas" style="width: 100%; height: calc(100% - 75px);"></canvas>  
            <div class="chart-controls">
              <button id="playPauseBtn">⏸️ 일시정지</button>
              <button id="resetBtn">⟲ 재시작</button>
              <button id="speedUpBtn">⏩ 속도 증가</button>
              <button id="speedDownBtn">⏪ 속도 감소</button>
            </div>
              <div style="margin-top: 5px; text-align: center; font-size: 0.85em;">
                <span style="color: #2c3e50;">누출원 좌표 정보</span>
                <div style="margin-top: 2px; color: #2c3e50;">센서 반응도: <span style="color: #dc3545; font-weight: bold;">높음</span></div>
              </div>
          `;
          
          showChartPopup();
          
          const ctx = document.getElementById('leakChartCanvas').getContext('2d');
          leakChart = new Chart(ctx, {
            type: 'line',
            data: {
              datasets: currentLeakDetectionValueIndices.map((obj, index) => ({
                label: obj.name,
                data: [],
                borderColor: `hsl(${(index * 60 + 180) % 360}, 60%, 45%)`,
                backgroundColor: `hsla(${(index * 60 + 180) % 360}, 60%, 45%, 0.1)`,
                borderWidth: 2,
                pointRadius: 2,
                pointHoverRadius: 5,
                fill: false,
                tension: 0.2
              }))
            },
            options: {
              animation: false,
              scales: {
                x: {
                  type: 'linear',
                  title: { display: true, text: 'Time [s]', color: '#333', font: { size: 10 } },
                  min: 0,
                  ticks: { color: '#555', font: {size: 9}},
                  grid: { color: 'rgba(0,0,0,0.05)'}
                },
                y: {
                  title: { display: true, text: 'Sensor Reading [ppm]', color: '#333', font: { size: 10 } },
                  min: 0,
                  ticks: { color: '#555', font: {size: 9}},
                  grid: { color: 'rgba(0,0,0,0.05)'}
                }
              },
              plugins: {
                legend: {  
                  labels: { color: '#333', font: { size: 9 } },
                  position: 'top'
                },
                tooltip: {
                  backgroundColor: 'rgba(255, 255, 255, 0.95)',
                  titleFont: { size: 12 },
                  bodyFont: { size: 10 },
                  titleColor: '#333',
                  bodyColor: '#333',
                  borderColor: 'rgba(0, 123, 255, 0.3)',
                  borderWidth: 1
                }
              },
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false
              }
            }
          });
          
          setupChartControls();  
          
          leakTimer = setInterval(() => {
            updateChartData(true);  
          },1000 / currentChartSpeedFactor);
        })        .catch(error => {
          console.error(`Leak #${leakNumber} 시나리오 데이터 로드 오류:`, error);
          document.getElementById('popup-content').innerHTML = `
            <p style="color:red;">데이터 로드 실패: ${error.message}</p>
            <p>파일 경로: ${localCsvFilePath}</p>
            <button id="retryBtn" style="margin-top: 10px; padding: 5px 10px; background-color: rgba(0, 123, 255, 0.1); border: 1px solid rgba(0, 123, 255, 0.5); color: #007bff; border-radius: 4px; cursor: pointer;">
              다시 시도
            </button>
            <button id="defaultDataBtn" style="margin-top: 10px; margin-left: 5px; padding: 5px 10px; background-color: rgba(108, 117, 125, 0.1); border: 1px solid rgba(108, 117, 125, 0.5); color: #6c757d; border-radius: 4px; cursor: pointer;">
              기본 데이터로 보기
            </button>
          `;
          showChartPopup();
          
          // Add event listeners for retry and fallback buttons
          setTimeout(() => {
            const retryBtn = document.getElementById('retryBtn');
            const defaultDataBtn = document.getElementById('defaultDataBtn');
            
            if (retryBtn) {
              retryBtn.addEventListener('click', function() {
                loadLeakScenario(leakNumber);
              });
            }
            
            if (defaultDataBtn) {
              defaultDataBtn.addEventListener('click', function() {
                loadLeakScenario(7); // Load the known-good data
              });
            }
          }, 100);
        });
    }
      document.addEventListener('click', (event) => {
      if (event.target.closest('#popup') || event.target.closest('#overlay-buttons') || event.target.closest('#graphModal')) {
        return;
      }

      if (!popupLocked && !event.target.closest('.ui-panel') && !event.target.closest('#overlay-buttons button')) {
        closePopup();
        const graphModal = document.getElementById('graphModal');
        if (graphModal.style.display !== 'none') {
            closeGraphModal();
        }
        return;  
      }
      
      const viewerRect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - viewerRect.left) / viewerRect.width) * 2 - 1;
      mouse.y = -((event.clientY - viewerRect.top) / viewerRect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(window.clickableCubes || [], false);  
      
      if (intersects.length > 0) {
        const obj = intersects[0].object;
        if (obj.userData && obj.userData.leakNumber) {
          console.log(`Leak point clicked: ${obj.userData.name}, leak number: ${obj.userData.leakNumber}`);
          
          // 상태 큐브를 표시하고 LeakDetection 모드 활성화
          LeakDetection(); // 상태 큐브를 먼저 생성
          
          // 그 다음에 해당 누출원 시나리오 로드
          setTimeout(() => {
            loadLeakScenario(obj.userData.leakNumber);
          }, 100); // Allow LeakDetection to set up the popup first
        }
      }
    });

  </script>

</body>
</html>
